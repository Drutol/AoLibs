{
    "docs": [
        {
            "location": "/",
            "text": "AoLibs\n\n\nSet of various libraries that I happened to write during my Xamarin adventures. They are in final stages of testing in real project. Later on I'll write proper docs and make the code more appropriate for nuget library.\n\n\n\n\nI'm currently writing docs in readmes. They will be visbile in repo and on \nGitHub pages\n\n\n\n\nFeatures\n\n\nLibrary supports \niOS\n and \nAndroid\n projects. It's divided into three parts:\n\n\n\n\nAoLibs.Navigation\n\n\nProvides cross platform navigation utilities.\n\n\n\n\n\n\nAoLibs.Adapters\n\n\nVarious adapters gathering features that require writing platform specific code.\n\n\n\n\n\n\nAoLibs.Utilities\n\n\nCompletly random things that I tend to use in my projects\n\n\n\n\n\n\n\n\nDependencies\n\n\nThese libraries are built against MvvmLight libraries.",
            "title": "Home"
        },
        {
            "location": "/#aolibs",
            "text": "Set of various libraries that I happened to write during my Xamarin adventures. They are in final stages of testing in real project. Later on I'll write proper docs and make the code more appropriate for nuget library.   I'm currently writing docs in readmes. They will be visbile in repo and on  GitHub pages",
            "title": "AoLibs"
        },
        {
            "location": "/#features",
            "text": "Library supports  iOS  and  Android  projects. It's divided into three parts:   AoLibs.Navigation  Provides cross platform navigation utilities.    AoLibs.Adapters  Various adapters gathering features that require writing platform specific code.    AoLibs.Utilities  Completly random things that I tend to use in my projects",
            "title": "Features"
        },
        {
            "location": "/#dependencies",
            "text": "These libraries are built against MvvmLight libraries.",
            "title": "Dependencies"
        },
        {
            "location": "/installation/",
            "text": "TODO",
            "title": "Installation"
        },
        {
            "location": "/installation/#todo",
            "text": "",
            "title": "TODO"
        },
        {
            "location": "/navigation/",
            "text": "Navigation\n\n\nThe goal is to provide lightweight solution for cross-platform navigation.\n\n\nThe main interface you will be using in your shared codebase is \nINavigationManager<TPageIdentifier>\n where \nTPageIdentifier\n is usally a simple enum with all your pages.\n\n\n\n\nBelow I'll descibe shared concepts between Android&iOS. Setup and platofrm specific things are contained in separate pages.\n\n\n\n\nPage providers\n\n\nThe page definitions dictionary takes in pair of \nTPageIdentifier\n which is simple \nenum\n in most cases and instance of class that implements \nIPageProvider<INavigationPage>\n. There are two implemented as of now:\n\n\n\n\nCachedPageProvider\n\n\nThis provider preserves the state of its page so that when we navigate there it will look the same.\n\n\n\n\n\n\nOneshotPageProvider\n\n\nHere we are providing the page instance just once, each navigation will create new uninitilized page. The use-case of it is to avoid manually cleaning pages like \nRegisterPage\n. I suggest disabling cache in your IoC container for associated ViewModel.\n\n\n\n\n\n\n\n\nNavigation lifecycle events\n\n\nINavigationPage\n provides following events for you to override from platform specific class:\n\n\npublic virtual void NavigatedTo();\npublic virtual void NavigatedBack();\npublic virtual void NavigatedFrom();\n\n\n\n\n\n\nNavigatedTo\n\n\nIs called when we navigate forward to this fragment.\n\n\neg. SignInPage -> DashboardPage\n\n\nDashboardPage invokes \nNavigatedTo\n\n\n\n\n\n\n\n\n\n\nNavigatedBack\n\n\nCalled when we navigate backwards to the page we have alraedy been on.\n\n\neg. SignInPage <- DashboardPage\n\n\nSignInPage invokes \nNavigatedBack\n\n\n\n\n\n\n\n\n\n\nNavigatedFrom\n\n\nIs called whenever we leave the page.\n\n\n\n\n\n\n\n\nNavigation with arguments\n\n\nIt's possible to invoke navigation with arguments. It allows us to separate ViewModels and avoid communication spaghetti code. \n\n\nINavigationManager<TPageIdentifier>\n allows to pass \nargs\n parameter which is plain \nSystem.Object\n. These arguments will appear in \nNavigationArguments\n property within fragment class.\n\n\nNavigation backstack options\n\n\nThere are defined following naviagtion options:\n\n\npublic enum NavigationBackstackOption\n{\n    AddToBackstack,\n    SetAsRootPage,\n    ClearBackstackToFirstOccurence,\n    NoBackstack,\n    ForceNewPageInstance\n}\n\n\n\n\n\n\nAddToBackstack\n\n\nBasic default option, current page will be added to backstack when navigating.\n\n\n\n\n\n\nSetAsRootPage\n\n\nClears backstack and then navigates to given page essentially making it a root page.\n\n\n\n\n\n\nClearBackstackToFirstOccurence\n\n\nAllows to \"jump\" to page that is already on backstack, let's say you have registration process consisting of multiple pages and once you are done you need to get back to \"Sign in\" page, with this option you can go back multiple pages.\n\n\n\n\n\n\nNoBackstack\n\n\nCurrent page won't be added to backstack on navigation.\n\n\n\n\n\n\nForceNewPageInstance\n\n\nRequests \nIPageProvider\n to recreate page instance before navigating.",
            "title": "Navigation"
        },
        {
            "location": "/navigation/#navigation",
            "text": "The goal is to provide lightweight solution for cross-platform navigation.  The main interface you will be using in your shared codebase is  INavigationManager<TPageIdentifier>  where  TPageIdentifier  is usally a simple enum with all your pages.   Below I'll descibe shared concepts between Android&iOS. Setup and platofrm specific things are contained in separate pages.",
            "title": "Navigation"
        },
        {
            "location": "/navigation/#page-providers",
            "text": "The page definitions dictionary takes in pair of  TPageIdentifier  which is simple  enum  in most cases and instance of class that implements  IPageProvider<INavigationPage> . There are two implemented as of now:   CachedPageProvider  This provider preserves the state of its page so that when we navigate there it will look the same.    OneshotPageProvider  Here we are providing the page instance just once, each navigation will create new uninitilized page. The use-case of it is to avoid manually cleaning pages like  RegisterPage . I suggest disabling cache in your IoC container for associated ViewModel.",
            "title": "Page providers"
        },
        {
            "location": "/navigation/#navigation-lifecycle-events",
            "text": "INavigationPage  provides following events for you to override from platform specific class:  public virtual void NavigatedTo();\npublic virtual void NavigatedBack();\npublic virtual void NavigatedFrom();   NavigatedTo  Is called when we navigate forward to this fragment.  eg. SignInPage -> DashboardPage  DashboardPage invokes  NavigatedTo      NavigatedBack  Called when we navigate backwards to the page we have alraedy been on.  eg. SignInPage <- DashboardPage  SignInPage invokes  NavigatedBack      NavigatedFrom  Is called whenever we leave the page.",
            "title": "Navigation lifecycle events"
        },
        {
            "location": "/navigation/#navigation-with-arguments",
            "text": "It's possible to invoke navigation with arguments. It allows us to separate ViewModels and avoid communication spaghetti code.   INavigationManager<TPageIdentifier>  allows to pass  args  parameter which is plain  System.Object . These arguments will appear in  NavigationArguments  property within fragment class.",
            "title": "Navigation with arguments"
        },
        {
            "location": "/navigation/#navigation-backstack-options",
            "text": "There are defined following naviagtion options:  public enum NavigationBackstackOption\n{\n    AddToBackstack,\n    SetAsRootPage,\n    ClearBackstackToFirstOccurence,\n    NoBackstack,\n    ForceNewPageInstance\n}   AddToBackstack  Basic default option, current page will be added to backstack when navigating.    SetAsRootPage  Clears backstack and then navigates to given page essentially making it a root page.    ClearBackstackToFirstOccurence  Allows to \"jump\" to page that is already on backstack, let's say you have registration process consisting of multiple pages and once you are done you need to get back to \"Sign in\" page, with this option you can go back multiple pages.    NoBackstack  Current page won't be added to backstack on navigation.    ForceNewPageInstance  Requests  IPageProvider  to recreate page instance before navigating.",
            "title": "Navigation backstack options"
        },
        {
            "location": "/navigation-android/",
            "text": "Introduction\n\n\nThe idea behind this navigation mechanism is simillar to how WPF/UWP's \n<Frame>\n element works. Namely we are have one root page that hosts all other pages. These pages are managed by libary within this frame.\n\n\nSetup\n\n\nAll pages are hosted as \nFragments\n, I'm assuming using single activity pattern.\nGiven a single android activity with layout:\n\n\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n              android:layout_width=\"match_parent\"\n              android:layout_height=\"match_parent\"\n              android:orientation=\"vertical\">\n\n  <FrameLayout android:layout_width=\"match_parent\"\n               android:layout_height=\"match_parent\"\n               android:id=\"@+id/RootView\" />\n</LinearLayout>\n\n\n\n\nNow we will want to initialize library from code.\nThe \nRootView\n \nFrameLayout\n will be hosting all our pages within itself.\n\n\nprotected override void OnCreate(Bundle savedInstanceState)\n{\n    base.OnCreate(savedInstanceState);\n\n    SetContentView(Resource.Layout.main);\n\n    var pageDefinitions = new Dictionary<PageIndex, IPageProvider<NavigationFragmentBase>>\n    {\n        // cached\n        {PageIndex.WelcomePage, new CachedPageProvider<WelcomePageFragment>()},\n        // oneshots\n        {PageIndex.SignInPage, new OneshotPageProvider<SignInPageFragment>()},\n    };\n\n    var manager = new NavigationManager<PageIndex>(\n        fragmentManager: SupportFragmentManager,\n        rootFrame: RootView,\n        pageDefinitions: pageDefinitions)\n}\n\n\n\n\nNow we can happily use our \nINavigationManager<TPageIdentifier>\n in our ViewModels!\n\n\nAdditional configuration\n\n\nAdding new pages\n\n\nAs we can see there are two pages defined \nWelcomePageFragment\n and \nSignInPageFragment\n. I'm providing base clases for fragments so it's very easy to add new content.\n\n\nType hierarchy:\n\n\n\n\n\n\nINavigationPage\n\n\n\n\n\n\nNavigationFragmentBase\n\n\n\n\nFragmentBase<TViewModel>\n\n\n\n\n\n\n\n\n\n\n\n\nNavigationFragmentBase\n inherits from Andoroid's \nFragment\n class and wraps its functionality. Let's say we want to create new page \nSplashPage\n.\n1. Create new class called for example \nSplashPageFragment\n\n2. Make it inherit from \nFragmentBase<TViewModel>\n\n\npublic class SplashPageFragment : FragmentBase<SplashViewModel>\n{\n    public override int LayoutResourceId { get; } = Resource.Layout.splash_page;\n\n    protected override void InitBindings()\n    {\n\n    }\n}\n\n\n\n\n\n\nThere are 2 required elements:\n\n\nLayoutResourceId\n which indicates which layout the fragment is associated with.\n\n\nInitBinings\n method in which we will define our bindings to ViewModel.\n\n\nAdd new entry in \npageDefinitions\n\n\n\n\nTransition animations\n\n\nIf you want to include transition animations when navigating you will want to use \nAction<FragmentTransaction> interceptTransaction\n parameter of \nNavigationManager\n's constructor. It will expose \nFragmentTransaction\n so you change whatever you want before actually commiting new page. For example:\n\n\nprivate void InterceptTransaction(FragmentTransaction fragmentTransaction)\n{\n    fragmentTransaction.SetCustomAnimations(\n        Resource.Animator.animation_slide_bottom,\n        Resource.Animator.animation_fade_out);\n}\n\n\n\n\nViewModel injection\n\n\nThe generic parameter of \nFragmentBase<TViewModel>\n allows you to specify which ViewModel to pull for given fragment. ViewModel will be available in \nViewModel\n property in your fragment.\nThis requires providing implementation of \nIViewModelResolver\n interface which will pull appropriate ViewModels from your IoC for example.\n\n\nprivate class ViewModelResolver : IViewModelResolver\n{\n    public TViewModel Resolve<TViewModel>()\n    {\n        using (var scope = ViewModelLocator.ObtainScope())\n        {\n            return scope.Resolve<TViewModel>();\n        }\n    }\n}\n\n\n\n\nThis \nViewModelResolver\n can be assigned to static property found on \nNavigationFragmentBase\n.\n\n\nNavigationFragmentBase.ViewModelResolver = new ViewModelResolver();\n\n\n\n\nBindings\n\n\nWhen we are talking navigation we are talking bindings lifecycle too. \nFragmentBase\n class handles them too. Since the library is based on MVVMLight library we are using its bindings. \n\n\nYou will want to add all of them to \nBindings\n which is of type \nList<Binding>\n, they will be properly attached and reattached when needed.\n\n\nYou are supposed to add all your bindings in \nInitBindings\n method which is called once per fragment instance or when bindigs need to be recreated.\n\n\nIf you don't have any bindings added to \nBindings\n, yet you don't wat the method to be fired again you can call this constructor:\n\n\npublic NavigationFragmentBase(bool hasNonTrackableBindings = false);\n\n\n\n\nExample:\n\n\nprotected override void InitBindings()\n{\n    Bindings.Add(this.SetBinding(() => ViewModel.Toggle).WhenSourceChanges(() =>\n    {\n        ToggleValue.Text = ViewModel.Toggle ? \"ON\" : \"OFF\";\n    }));\n\n    Bindings.Add(this.SetBinding(() => ViewModel.Value, () => Value.Text));\n}\n\n\n\n\nDisclaimer: \nValue\n and \nToggleValue\n are \nTextViews\n.\n\n\nNotes\n\n\n\n\nThe \nMainActivity\n will have to inherit \nAppCompatActivity\n.",
            "title": "Android Navigation"
        },
        {
            "location": "/navigation-android/#introduction",
            "text": "The idea behind this navigation mechanism is simillar to how WPF/UWP's  <Frame>  element works. Namely we are have one root page that hosts all other pages. These pages are managed by libary within this frame.",
            "title": "Introduction"
        },
        {
            "location": "/navigation-android/#setup",
            "text": "All pages are hosted as  Fragments , I'm assuming using single activity pattern.\nGiven a single android activity with layout:  <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n              android:layout_width=\"match_parent\"\n              android:layout_height=\"match_parent\"\n              android:orientation=\"vertical\">\n\n  <FrameLayout android:layout_width=\"match_parent\"\n               android:layout_height=\"match_parent\"\n               android:id=\"@+id/RootView\" />\n</LinearLayout>  Now we will want to initialize library from code.\nThe  RootView   FrameLayout  will be hosting all our pages within itself.  protected override void OnCreate(Bundle savedInstanceState)\n{\n    base.OnCreate(savedInstanceState);\n\n    SetContentView(Resource.Layout.main);\n\n    var pageDefinitions = new Dictionary<PageIndex, IPageProvider<NavigationFragmentBase>>\n    {\n        // cached\n        {PageIndex.WelcomePage, new CachedPageProvider<WelcomePageFragment>()},\n        // oneshots\n        {PageIndex.SignInPage, new OneshotPageProvider<SignInPageFragment>()},\n    };\n\n    var manager = new NavigationManager<PageIndex>(\n        fragmentManager: SupportFragmentManager,\n        rootFrame: RootView,\n        pageDefinitions: pageDefinitions)\n}  Now we can happily use our  INavigationManager<TPageIdentifier>  in our ViewModels!",
            "title": "Setup"
        },
        {
            "location": "/navigation-android/#additional-configuration",
            "text": "",
            "title": "Additional configuration"
        },
        {
            "location": "/navigation-android/#adding-new-pages",
            "text": "As we can see there are two pages defined  WelcomePageFragment  and  SignInPageFragment . I'm providing base clases for fragments so it's very easy to add new content.  Type hierarchy:    INavigationPage    NavigationFragmentBase   FragmentBase<TViewModel>       NavigationFragmentBase  inherits from Andoroid's  Fragment  class and wraps its functionality. Let's say we want to create new page  SplashPage .\n1. Create new class called for example  SplashPageFragment \n2. Make it inherit from  FragmentBase<TViewModel>  public class SplashPageFragment : FragmentBase<SplashViewModel>\n{\n    public override int LayoutResourceId { get; } = Resource.Layout.splash_page;\n\n    protected override void InitBindings()\n    {\n\n    }\n}   There are 2 required elements:  LayoutResourceId  which indicates which layout the fragment is associated with.  InitBinings  method in which we will define our bindings to ViewModel.  Add new entry in  pageDefinitions",
            "title": "Adding new pages"
        },
        {
            "location": "/navigation-android/#transition-animations",
            "text": "If you want to include transition animations when navigating you will want to use  Action<FragmentTransaction> interceptTransaction  parameter of  NavigationManager 's constructor. It will expose  FragmentTransaction  so you change whatever you want before actually commiting new page. For example:  private void InterceptTransaction(FragmentTransaction fragmentTransaction)\n{\n    fragmentTransaction.SetCustomAnimations(\n        Resource.Animator.animation_slide_bottom,\n        Resource.Animator.animation_fade_out);\n}",
            "title": "Transition animations"
        },
        {
            "location": "/navigation-android/#viewmodel-injection",
            "text": "The generic parameter of  FragmentBase<TViewModel>  allows you to specify which ViewModel to pull for given fragment. ViewModel will be available in  ViewModel  property in your fragment.\nThis requires providing implementation of  IViewModelResolver  interface which will pull appropriate ViewModels from your IoC for example.  private class ViewModelResolver : IViewModelResolver\n{\n    public TViewModel Resolve<TViewModel>()\n    {\n        using (var scope = ViewModelLocator.ObtainScope())\n        {\n            return scope.Resolve<TViewModel>();\n        }\n    }\n}  This  ViewModelResolver  can be assigned to static property found on  NavigationFragmentBase .  NavigationFragmentBase.ViewModelResolver = new ViewModelResolver();",
            "title": "ViewModel injection"
        },
        {
            "location": "/navigation-android/#bindings",
            "text": "When we are talking navigation we are talking bindings lifecycle too.  FragmentBase  class handles them too. Since the library is based on MVVMLight library we are using its bindings.   You will want to add all of them to  Bindings  which is of type  List<Binding> , they will be properly attached and reattached when needed.  You are supposed to add all your bindings in  InitBindings  method which is called once per fragment instance or when bindigs need to be recreated.  If you don't have any bindings added to  Bindings , yet you don't wat the method to be fired again you can call this constructor:  public NavigationFragmentBase(bool hasNonTrackableBindings = false);  Example:  protected override void InitBindings()\n{\n    Bindings.Add(this.SetBinding(() => ViewModel.Toggle).WhenSourceChanges(() =>\n    {\n        ToggleValue.Text = ViewModel.Toggle ? \"ON\" : \"OFF\";\n    }));\n\n    Bindings.Add(this.SetBinding(() => ViewModel.Value, () => Value.Text));\n}  Disclaimer:  Value  and  ToggleValue  are  TextViews .",
            "title": "Bindings"
        },
        {
            "location": "/navigation-android/#notes",
            "text": "The  MainActivity  will have to inherit  AppCompatActivity .",
            "title": "Notes"
        },
        {
            "location": "/navigation-ios/",
            "text": "TODO",
            "title": "iOS Navigation"
        },
        {
            "location": "/navigation-ios/#todo",
            "text": "",
            "title": "TODO"
        },
        {
            "location": "/adapters/",
            "text": "Adapters\n\n\nThe library comes packed with quite a few adapters that will help you avoid writing boilerplate code for platfrom dependednt functionalities.\n\n\n\n\nAdapter is a class which provides same functionality that has to be implemented differently on different platforms.\n\n\n\n\nProvided adapters\n\n\nMain interfaces which can be used in shared codebase are found in \nAoLibs.Adapters.Core\n.\n\n\n\n\nIClipboardProvider\n\n\nIDataCache\n\n\nIDispatcherAdapter\n\n\nIFileStorageProvider\n\n\nILifecycleInfoProvider\n\n\nIMessageBoxProvider\n\n\nIPhoneCallAdapter\n\n\nIPhotoPickerAdapter\n\n\nIPickerAdapter\n\n\nISettingsProvider\n\n\nIUriLauncherAdapter\n\n\nIVersionProvider\n\n\n\n\nI'll provide more details on the ones that may be not obvious.\n\n\nDataCache\n\n\nIt depends on \nIFileStorageProvider\n. Uses Json.NET to serialize given data and save it to file for storage. Object are wrapped in object with timestamp so it's possible to specify for how long this piece of data stays valid.\n\n\nDispatcherAdapter\n\n\nRuns action on UI thread... that's it.\n\n\nLifecycleInfoProvider\n\n\nRequires manual invocation of methods.\n\n\nSettingsProvider\n\n\nProvides set of methods allowing to storage data in application's settings construct.",
            "title": "Adapters"
        },
        {
            "location": "/adapters/#adapters",
            "text": "The library comes packed with quite a few adapters that will help you avoid writing boilerplate code for platfrom dependednt functionalities.   Adapter is a class which provides same functionality that has to be implemented differently on different platforms.",
            "title": "Adapters"
        },
        {
            "location": "/adapters/#provided-adapters",
            "text": "Main interfaces which can be used in shared codebase are found in  AoLibs.Adapters.Core .   IClipboardProvider  IDataCache  IDispatcherAdapter  IFileStorageProvider  ILifecycleInfoProvider  IMessageBoxProvider  IPhoneCallAdapter  IPhotoPickerAdapter  IPickerAdapter  ISettingsProvider  IUriLauncherAdapter  IVersionProvider   I'll provide more details on the ones that may be not obvious.",
            "title": "Provided adapters"
        },
        {
            "location": "/adapters/#datacache",
            "text": "It depends on  IFileStorageProvider . Uses Json.NET to serialize given data and save it to file for storage. Object are wrapped in object with timestamp so it's possible to specify for how long this piece of data stays valid.",
            "title": "DataCache"
        },
        {
            "location": "/adapters/#dispatcheradapter",
            "text": "Runs action on UI thread... that's it.",
            "title": "DispatcherAdapter"
        },
        {
            "location": "/adapters/#lifecycleinfoprovider",
            "text": "Requires manual invocation of methods.",
            "title": "LifecycleInfoProvider"
        },
        {
            "location": "/adapters/#settingsprovider",
            "text": "Provides set of methods allowing to storage data in application's settings construct.",
            "title": "SettingsProvider"
        },
        {
            "location": "/adapters-android/",
            "text": "TODO",
            "title": "Android Adapters"
        },
        {
            "location": "/adapters-android/#todo",
            "text": "",
            "title": "TODO"
        },
        {
            "location": "/android-recycler-adapters/",
            "text": "Recycler View Adapters\n\n\nAdapters library contains set of adapters that eliminate need for creating custom adapter classes.\n\n\nApplicable types:\n\n\nAdapters:\n\n\nObservableRecyclerAdapter<TItem, THolder>\n\n\nObservableRecyclerAdapterWithFooter<TItem, THolder, TFooterHolder>\n\n\nObservableRecyclerAdapterWithMultipleViewTypes<TItemBase, THolder>\n\n\nObservableRecyclerAdapterWithMultipleViewTypesAndFooter<TItemBase, THolder, TFooterHolder>\n\n\nViewHolder:\n\n\nBindingViewHolderBase<T>\n\n\nUtilities:\n\n\nItemEntry\n\n\nSpecializedItemEntry<TSpecializedItem, TSpecializedHolder>\n\n\nThese classes provide an easy way to quickly implement recycler views for various scenarios starting from simple list to elaborate lists with various ViewModel bound elements with different layouts. All of provided adapters are utilising events of \nObservableCollection<T>\n.\n\n\nThe \nObservableRecyclerAdapter<TItem, THolder>\n is base class for all other specialized adapters.\n\n\nSimple setup\n\n\nSo let's say we want to set-up simple recycler view list. Let's assume we have layout already created with \nRecyclerView\n named \nRecyclerView\n\n\nRecyclerView.SetAdapter(\n    adapter: new ObservableRecyclerAdapter<Item, ItemViewHolder>(\n        items: ViewModel.Items, \n        dataTemplate: DataTemplate,\n        itemTemplate: ItemTemplate,\n        holderFactory: HolderFactory));\n\nprivate void DataTemplate(Item item, ItemViewHolder holder, int position)\n{\n    holder.SomeTextView.Text = item.SomeTextValue;\n}\n\nprivate View ItemTemplate(int viewType)\n{\n    return LayoutInflater.Inflate(Resource.Layout.some_item_layout, null);\n}\n\nprivate ItemViewHolder HolderFactory(ViewGroup parent, int viewType, View view)\n{\n    return new ItemViewHolder(view);\n}\n\n\n\n\nWe have 3 methods being passed to adapter's constructor:\n\n \nDataTemplate\n\n    * Here we are defining how to display given item in the list, you will receive current item and holder that will have to display it.\n\n \nItemTemplate\n\n    * Here you should provide view that will be later bound to view holder.\n* \nHolderFactory\n\n    * Here we are instantinating holder for our virtualised items. This parameter is optional if your holder has public parameterless constructor and you don't need custom instantination.\n\n\nView Stretching\n\n\nUnless specified the views in \nRecyclerView\n won't stretch horizontally. I've provided simple utility that takes care of it. \n\n\nRecyclerView.SetAdapter(\n    adapter: new ObservableRecyclerAdapter<Item, ItemViewHolder>(\n        items: ViewModel.Items, \n        dataTemplate: DataTemplate,\n        itemTemplate: ItemTemplate,\n        holderFactory: HolderFactory) {ApplyLayoutParams = true});\n\n\n\n\nIn order to use it you just have to set \nApplyLayoutParams\n property to \ntrue\n. Item containers will be assigned with proper \nRecyclerView.LayoutParams\n after inflating.\n\n\nFooter\n\n\nAdapter with footer is very similar to standard adapter:\n\n\nRecyclerView.SetAdapter(\n    new ObservableRecyclerAdapterWithFooter<Item, ItemViewHolder, FooterHolder>(\n            items: ViewModel.Items, \n            dataTemplate: DataTemplate, \n            holderFactory: HolderFactory, \n            itemTemplate: ItemTemplate,\n            footerDataTemplate: FooterDataTemplate,\n            footerFactory: FooterFactory,\n            footerTemplate: FooterTemplate)\n        {ApplyLayoutParams = true});\n\n...\n\nprivate View FooterTemplate(int viewType)\n{\n    return LayoutInflater.Inflate(Resource.Layout.some_footer, null);\n}\n\nprivate FooterHolder FooterFactory(ViewGroup parent, int viewType, View view)\n{\n    return new FooterHolder(view);\n}\n\nprivate void FooterDataTemplate(Item item, FooterHolder holder, int position)\n{\n    holder.ViewModel = ViewModel;\n}\n\n\n\n\nAll you have to do is to add 3 more delegates defining footer. Mind you that \nitem\n argument in \nFooterDataTemplate\n is \nnull\n as there's no item applicable for that position.\n\n\n\n\nNote: If your footer holder inherits from \nBindingViewHolderBase<TViewModel>\n the holder won't automatically update bindings, you have to assign your ViewModel manually to footer.\n\n\n\n\nBinding ViewHolders\n\n\nAs I've previously mentioned it's possbile to easily implement bindings for each list entry.\nAll you have to do is to make your ViewHolder inherit from \nBindingViewHolderBase<TViewModel>\n.\nFor exmaple:\n\n\nprivate class SomeHolder : BindingViewHolderBase<SomeViewModel>\n{\n    private readonly View _view;\n\n    private TextView _totalPriceLabel;\n\n    public FooterHolder(View view) : base(view)\n    {\n        _view = view;\n    }\n\n    public TextView TotalPriceLabel => _totalPriceLabel ??\n                                       (_totalPriceLabel = _view.FindViewById<TextView>(Resource.Id.TotalPriceLabel));\n\n    protected override void SetBindings()\n    {\n        Bindings.Add(this.SetBinding(() => ViewModel.TotalOrderPrice, () => TotalPriceLabel.Text)\n            .ConvertSourceToTarget(arg => arg.ToString(\"C\")));\n    }\n}\n\n\n\n\nThis view holder will make you implement \nSetBindings\n methods which works exactly the same as in Fragment's bindings. ViewModel swapping and bindings detaching will all be handled by the library.\n\n\nAdapters with multiple view types\n\n\nThis is where the fun starts. We have this lovely class \nObservableRecyclerAdapterWithMultipleViewTypes<TItemBase, THolder>\n which is inheriting from \nObservableRecyclerAdapter<TItemBase,THolder>\n.\nNotice that there's no longer \nTItem\n but \nTItemBase\n that means we will provide list of various elements. You can go for \nobject\n here but I encourage to make your models share same even empty interface for cleanliness sake. \n\n\nThe constructor has changed too: \nObservableRecyclerAdapterWithMultipleViewTypes(Dictionary<Type, IItemEntry> templates,IList<TItemBase> items)\n we will have to provide a definition of view per item.\n\n\nRecyclerView.SetAdapter(\nnew ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem,\n        RecyclerView.ViewHolder>(\n        new Dictionary<Type, ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem,\n            RecyclerView.ViewHolder>.IItemEntry>\n        {\n            {\n                typeof(FriendListHeaderItem),\n                new ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem,\n                    RecyclerView.ViewHolder>.SpecializedItemEntry<FriendListHeaderItem,\n                    SectionViewHolder>\n                {\n                    SpecializedHolderFactory = HeaderHolderFactory,\n                    ItemTemplate = HeaderItemTemplate,\n                    SpecializedDataTemplate = HeaderDataTemplate\n                }\n            },\n            {\n                typeof(InviteFriendItemViewModel),\n                new ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem,\n                    RecyclerView.ViewHolder>.SpecializedItemEntry<InviteFriendItemViewModel,\n                    FriendViewHolder>\n                {\n                    SpecializedHolderFactory = ItemHolderFactory,\n                    ItemTemplate = ItemTemplate,\n                    SpecializedDataTemplate = ItemDataTemplate\n                }\n            }\n        }, ViewModel.Friends)\n    {ApplyLayoutParams = true});\n\n\n\n\nIt may look intimidating at first but it's not that bad. Essentially we are providing pairs of \nType\n and \nIItemEntry\n implementations that are found in the library.\n\n\nIFriendListItem\n is our \nTItemBase\n\n\nTViewHolder\n will usually be simple \nRecyclerView.ViewHolder\n\n\nLet's take a closer look on view-type definiton.\n\n\n{\n    typeof(InviteFriendItemViewModel),\n    new ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem,\n        RecyclerView.ViewHolder>.SpecializedItemEntry<InviteFriendItemViewModel,\n        FriendViewHolder>\n    {\n        SpecializedHolderFactory = ItemHolderFactory,\n        ItemTemplate = ItemTemplate,\n        SpecializedDataTemplate = ItemDataTemplate\n    }\n}\n\n\n\n\nFirst thing we provide is our concrete type that is contained within the items to display, easy enough.\nNow comes the second part, \nObservableRecyclerAdapterWithMultipleViewTypes\n has inner classes:\n\n \nSpecializedItemEntry\n\n\n \nItemEntry\n\nThey are used to define the views. \nSpecializedItemEntry\n is an evolution of \nItemEntry\n that handles type casting so we don't have to do it manually each time.\n\n\npublic class SpecializedItemEntry<TSpecializedItem, TSpecializedHolder> : IItemEntry\n    where TSpecializedItem : TItemBase\n    where TSpecializedHolder : THolder\n\n\n\n\nInstead of getting \nTItemBase\n and \nTHolder\n passed to our \nDataTemplate\n we will be getting solid instances of \nInviteFriendItemViewModel\n and \nFriendViewHolder\n. If you wish to do the casting manuall you can use \nItemEntry\n.\n\n\n\n\nDon't use \nHolderFactory\n and \nDataTemplate\n properties in \nSpecializedItemEntry\n and use \nSpecializedHolderFactory\n and \nSpecializedDataTemplate\n properties. Exception will be thrown otherwise.\n\n\n\n\n{\n    typeof(RestaurantPageMenuItemViewModel),\n    new ObservableRecyclerAdapterWithMultipleViewTypes<\n            RestaurantPageViewModel.IRestaurantMenuItem, RecyclerView.ViewHolder>.ItemEntry\n        {\n            ItemTemplate = MenuItemTemplate,\n            DataTemplate = MenuDataTemplate,\n            HolderFactory = MenuHolderFactory\n        }\n}\n\n\n\n\nOf course you can use your friend \nBindingViewHolderBase<TViewModel>\n to achieve bindings per list item too!\n\n\nAdapters with multiple view types and footer\n\n\nThe ultimate form, handles just like \nObservableRecyclerAdapterWithMultipleViewTypes\n with addition of 3 delegates like in \nObservableRecyclerAdapterWithFooter\n. \n\n\nRecyclerView.SetAdapter(\n    new ObservableRecyclerAdapterWithMultipleViewTypesAndFooter<ReceiptPresentPageViewModel.IReceiptItem\n        , RecyclerView.ViewHolder, FooterViewHolder>(\n        new Dictionary<Type, ObservableRecyclerAdapterWithMultipleViewTypes<\n            ReceiptPresentPageViewModel.IReceiptItem, RecyclerView.ViewHolder>.IItemEntry>\n        {\n            {\n                typeof(ReceiptHeaderItem),\n                new ObservableRecyclerAdapterWithMultipleViewTypes<\n                        ReceiptPresentPageViewModel.IReceiptItem, RecyclerView.ViewHolder>.\n                    SpecializedItemEntry<ReceiptHeaderItem, HeaderViewHolder>\n                    {\n                        SpecializedHolderFactory = HeaderHolderFactory,\n                        ItemTemplate = HeaderItemTemplate,\n                        SpecializedDataTemplate = HeaderDataTemplate\n                    }\n            },\n            {\n                typeof(ReceiptOrderedDishItemViewModel),\n                new ObservableRecyclerAdapterWithMultipleViewTypes<\n                        ReceiptPresentPageViewModel.IReceiptItem, RecyclerView.ViewHolder>.\n                    SpecializedItemEntry<ReceiptOrderedDishItemViewModel, OrderedDishViewHolder>\n                    {\n                        SpecializedHolderFactory = OrderedDishHolderFactory,\n                        ItemTemplate = OrderedDishItemTemplate,\n                        SpecializedDataTemplate = OrderedDishDataTemplate\n                    }\n            },\n            {\n                typeof(ReceiptOrderSectionFooterItem),\n                new ObservableRecyclerAdapterWithMultipleViewTypes<\n                        ReceiptPresentPageViewModel.IReceiptItem, RecyclerView.ViewHolder>.\n                    SpecializedItemEntry<ReceiptOrderSectionFooterItem, SectionFooterViewHolder>\n                    {\n                        SpecializedHolderFactory = SectionFooterHolderFactory,\n                        ItemTemplate = SectionFooterItemTemplate,\n                        SpecializedDataTemplate = SectionFooterDataTemplate\n                    }\n            }\n        }, \n        ViewModel.CurrentReceipt, \n        FooterDataTemplate, \n        FooterFactory, \n        FooterTemplate)\n    {\n        ApplyLayoutParams = true\n    });",
            "title": "Android Recycler Adapters"
        },
        {
            "location": "/android-recycler-adapters/#recycler-view-adapters",
            "text": "Adapters library contains set of adapters that eliminate need for creating custom adapter classes.  Applicable types:  Adapters:  ObservableRecyclerAdapter<TItem, THolder>  ObservableRecyclerAdapterWithFooter<TItem, THolder, TFooterHolder>  ObservableRecyclerAdapterWithMultipleViewTypes<TItemBase, THolder>  ObservableRecyclerAdapterWithMultipleViewTypesAndFooter<TItemBase, THolder, TFooterHolder>  ViewHolder:  BindingViewHolderBase<T>  Utilities:  ItemEntry  SpecializedItemEntry<TSpecializedItem, TSpecializedHolder>  These classes provide an easy way to quickly implement recycler views for various scenarios starting from simple list to elaborate lists with various ViewModel bound elements with different layouts. All of provided adapters are utilising events of  ObservableCollection<T> .  The  ObservableRecyclerAdapter<TItem, THolder>  is base class for all other specialized adapters.",
            "title": "Recycler View Adapters"
        },
        {
            "location": "/android-recycler-adapters/#simple-setup",
            "text": "So let's say we want to set-up simple recycler view list. Let's assume we have layout already created with  RecyclerView  named  RecyclerView  RecyclerView.SetAdapter(\n    adapter: new ObservableRecyclerAdapter<Item, ItemViewHolder>(\n        items: ViewModel.Items, \n        dataTemplate: DataTemplate,\n        itemTemplate: ItemTemplate,\n        holderFactory: HolderFactory));\n\nprivate void DataTemplate(Item item, ItemViewHolder holder, int position)\n{\n    holder.SomeTextView.Text = item.SomeTextValue;\n}\n\nprivate View ItemTemplate(int viewType)\n{\n    return LayoutInflater.Inflate(Resource.Layout.some_item_layout, null);\n}\n\nprivate ItemViewHolder HolderFactory(ViewGroup parent, int viewType, View view)\n{\n    return new ItemViewHolder(view);\n}  We have 3 methods being passed to adapter's constructor:   DataTemplate \n    * Here we are defining how to display given item in the list, you will receive current item and holder that will have to display it.   ItemTemplate \n    * Here you should provide view that will be later bound to view holder.\n*  HolderFactory \n    * Here we are instantinating holder for our virtualised items. This parameter is optional if your holder has public parameterless constructor and you don't need custom instantination.",
            "title": "Simple setup"
        },
        {
            "location": "/android-recycler-adapters/#view-stretching",
            "text": "Unless specified the views in  RecyclerView  won't stretch horizontally. I've provided simple utility that takes care of it.   RecyclerView.SetAdapter(\n    adapter: new ObservableRecyclerAdapter<Item, ItemViewHolder>(\n        items: ViewModel.Items, \n        dataTemplate: DataTemplate,\n        itemTemplate: ItemTemplate,\n        holderFactory: HolderFactory) {ApplyLayoutParams = true});  In order to use it you just have to set  ApplyLayoutParams  property to  true . Item containers will be assigned with proper  RecyclerView.LayoutParams  after inflating.",
            "title": "View Stretching"
        },
        {
            "location": "/android-recycler-adapters/#footer",
            "text": "Adapter with footer is very similar to standard adapter:  RecyclerView.SetAdapter(\n    new ObservableRecyclerAdapterWithFooter<Item, ItemViewHolder, FooterHolder>(\n            items: ViewModel.Items, \n            dataTemplate: DataTemplate, \n            holderFactory: HolderFactory, \n            itemTemplate: ItemTemplate,\n            footerDataTemplate: FooterDataTemplate,\n            footerFactory: FooterFactory,\n            footerTemplate: FooterTemplate)\n        {ApplyLayoutParams = true});\n\n...\n\nprivate View FooterTemplate(int viewType)\n{\n    return LayoutInflater.Inflate(Resource.Layout.some_footer, null);\n}\n\nprivate FooterHolder FooterFactory(ViewGroup parent, int viewType, View view)\n{\n    return new FooterHolder(view);\n}\n\nprivate void FooterDataTemplate(Item item, FooterHolder holder, int position)\n{\n    holder.ViewModel = ViewModel;\n}  All you have to do is to add 3 more delegates defining footer. Mind you that  item  argument in  FooterDataTemplate  is  null  as there's no item applicable for that position.   Note: If your footer holder inherits from  BindingViewHolderBase<TViewModel>  the holder won't automatically update bindings, you have to assign your ViewModel manually to footer.",
            "title": "Footer"
        },
        {
            "location": "/android-recycler-adapters/#binding-viewholders",
            "text": "As I've previously mentioned it's possbile to easily implement bindings for each list entry.\nAll you have to do is to make your ViewHolder inherit from  BindingViewHolderBase<TViewModel> .\nFor exmaple:  private class SomeHolder : BindingViewHolderBase<SomeViewModel>\n{\n    private readonly View _view;\n\n    private TextView _totalPriceLabel;\n\n    public FooterHolder(View view) : base(view)\n    {\n        _view = view;\n    }\n\n    public TextView TotalPriceLabel => _totalPriceLabel ??\n                                       (_totalPriceLabel = _view.FindViewById<TextView>(Resource.Id.TotalPriceLabel));\n\n    protected override void SetBindings()\n    {\n        Bindings.Add(this.SetBinding(() => ViewModel.TotalOrderPrice, () => TotalPriceLabel.Text)\n            .ConvertSourceToTarget(arg => arg.ToString(\"C\")));\n    }\n}  This view holder will make you implement  SetBindings  methods which works exactly the same as in Fragment's bindings. ViewModel swapping and bindings detaching will all be handled by the library.",
            "title": "Binding ViewHolders"
        },
        {
            "location": "/android-recycler-adapters/#adapters-with-multiple-view-types",
            "text": "This is where the fun starts. We have this lovely class  ObservableRecyclerAdapterWithMultipleViewTypes<TItemBase, THolder>  which is inheriting from  ObservableRecyclerAdapter<TItemBase,THolder> .\nNotice that there's no longer  TItem  but  TItemBase  that means we will provide list of various elements. You can go for  object  here but I encourage to make your models share same even empty interface for cleanliness sake.   The constructor has changed too:  ObservableRecyclerAdapterWithMultipleViewTypes(Dictionary<Type, IItemEntry> templates,IList<TItemBase> items)  we will have to provide a definition of view per item.  RecyclerView.SetAdapter(\nnew ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem,\n        RecyclerView.ViewHolder>(\n        new Dictionary<Type, ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem,\n            RecyclerView.ViewHolder>.IItemEntry>\n        {\n            {\n                typeof(FriendListHeaderItem),\n                new ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem,\n                    RecyclerView.ViewHolder>.SpecializedItemEntry<FriendListHeaderItem,\n                    SectionViewHolder>\n                {\n                    SpecializedHolderFactory = HeaderHolderFactory,\n                    ItemTemplate = HeaderItemTemplate,\n                    SpecializedDataTemplate = HeaderDataTemplate\n                }\n            },\n            {\n                typeof(InviteFriendItemViewModel),\n                new ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem,\n                    RecyclerView.ViewHolder>.SpecializedItemEntry<InviteFriendItemViewModel,\n                    FriendViewHolder>\n                {\n                    SpecializedHolderFactory = ItemHolderFactory,\n                    ItemTemplate = ItemTemplate,\n                    SpecializedDataTemplate = ItemDataTemplate\n                }\n            }\n        }, ViewModel.Friends)\n    {ApplyLayoutParams = true});  It may look intimidating at first but it's not that bad. Essentially we are providing pairs of  Type  and  IItemEntry  implementations that are found in the library.  IFriendListItem  is our  TItemBase  TViewHolder  will usually be simple  RecyclerView.ViewHolder  Let's take a closer look on view-type definiton.  {\n    typeof(InviteFriendItemViewModel),\n    new ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem,\n        RecyclerView.ViewHolder>.SpecializedItemEntry<InviteFriendItemViewModel,\n        FriendViewHolder>\n    {\n        SpecializedHolderFactory = ItemHolderFactory,\n        ItemTemplate = ItemTemplate,\n        SpecializedDataTemplate = ItemDataTemplate\n    }\n}  First thing we provide is our concrete type that is contained within the items to display, easy enough.\nNow comes the second part,  ObservableRecyclerAdapterWithMultipleViewTypes  has inner classes:   SpecializedItemEntry    ItemEntry \nThey are used to define the views.  SpecializedItemEntry  is an evolution of  ItemEntry  that handles type casting so we don't have to do it manually each time.  public class SpecializedItemEntry<TSpecializedItem, TSpecializedHolder> : IItemEntry\n    where TSpecializedItem : TItemBase\n    where TSpecializedHolder : THolder  Instead of getting  TItemBase  and  THolder  passed to our  DataTemplate  we will be getting solid instances of  InviteFriendItemViewModel  and  FriendViewHolder . If you wish to do the casting manuall you can use  ItemEntry .   Don't use  HolderFactory  and  DataTemplate  properties in  SpecializedItemEntry  and use  SpecializedHolderFactory  and  SpecializedDataTemplate  properties. Exception will be thrown otherwise.   {\n    typeof(RestaurantPageMenuItemViewModel),\n    new ObservableRecyclerAdapterWithMultipleViewTypes<\n            RestaurantPageViewModel.IRestaurantMenuItem, RecyclerView.ViewHolder>.ItemEntry\n        {\n            ItemTemplate = MenuItemTemplate,\n            DataTemplate = MenuDataTemplate,\n            HolderFactory = MenuHolderFactory\n        }\n}  Of course you can use your friend  BindingViewHolderBase<TViewModel>  to achieve bindings per list item too!",
            "title": "Adapters with multiple view types"
        },
        {
            "location": "/android-recycler-adapters/#adapters-with-multiple-view-types-and-footer",
            "text": "The ultimate form, handles just like  ObservableRecyclerAdapterWithMultipleViewTypes  with addition of 3 delegates like in  ObservableRecyclerAdapterWithFooter .   RecyclerView.SetAdapter(\n    new ObservableRecyclerAdapterWithMultipleViewTypesAndFooter<ReceiptPresentPageViewModel.IReceiptItem\n        , RecyclerView.ViewHolder, FooterViewHolder>(\n        new Dictionary<Type, ObservableRecyclerAdapterWithMultipleViewTypes<\n            ReceiptPresentPageViewModel.IReceiptItem, RecyclerView.ViewHolder>.IItemEntry>\n        {\n            {\n                typeof(ReceiptHeaderItem),\n                new ObservableRecyclerAdapterWithMultipleViewTypes<\n                        ReceiptPresentPageViewModel.IReceiptItem, RecyclerView.ViewHolder>.\n                    SpecializedItemEntry<ReceiptHeaderItem, HeaderViewHolder>\n                    {\n                        SpecializedHolderFactory = HeaderHolderFactory,\n                        ItemTemplate = HeaderItemTemplate,\n                        SpecializedDataTemplate = HeaderDataTemplate\n                    }\n            },\n            {\n                typeof(ReceiptOrderedDishItemViewModel),\n                new ObservableRecyclerAdapterWithMultipleViewTypes<\n                        ReceiptPresentPageViewModel.IReceiptItem, RecyclerView.ViewHolder>.\n                    SpecializedItemEntry<ReceiptOrderedDishItemViewModel, OrderedDishViewHolder>\n                    {\n                        SpecializedHolderFactory = OrderedDishHolderFactory,\n                        ItemTemplate = OrderedDishItemTemplate,\n                        SpecializedDataTemplate = OrderedDishDataTemplate\n                    }\n            },\n            {\n                typeof(ReceiptOrderSectionFooterItem),\n                new ObservableRecyclerAdapterWithMultipleViewTypes<\n                        ReceiptPresentPageViewModel.IReceiptItem, RecyclerView.ViewHolder>.\n                    SpecializedItemEntry<ReceiptOrderSectionFooterItem, SectionFooterViewHolder>\n                    {\n                        SpecializedHolderFactory = SectionFooterHolderFactory,\n                        ItemTemplate = SectionFooterItemTemplate,\n                        SpecializedDataTemplate = SectionFooterDataTemplate\n                    }\n            }\n        }, \n        ViewModel.CurrentReceipt, \n        FooterDataTemplate, \n        FooterFactory, \n        FooterTemplate)\n    {\n        ApplyLayoutParams = true\n    });",
            "title": "Adapters with multiple view types and footer"
        },
        {
            "location": "/android-listeners/",
            "text": "",
            "title": "Android Listeners"
        },
        {
            "location": "/app-variables/",
            "text": "AppVariables\n\n\nIt's a higher level mechanism that uses \nISettingsProvider\n and \nIFileStorageProvider\n to provide easy typed access to stored data.\n\n\n\n\nNote: It's only meant for reference types, don't use simple types.\n\n\n\n\npublic class AppVariables : AppVariablesBase\n{\n    public AppVariables(ISettingsProvider settingsProvider, IDataCache dataCache = null) \n            : base(settingsProvider, dataCache)\n    {\n\n    }\n\n    public AppVariables(ISyncStorage syncStorage, IAsyncStorage asyncStorage = null) \n            : base(syncStorage, asyncStorage)\n    {\n\n    }\n\n    [Variable]\n    public Holder<TokenModel> TokenModel { get; set; }\n\n    [Variable]\n    public Holder<VideoLibrary> VideoLibrary { get; set; }\n}\n\n\n\n\nSingle property of type \nHolder<T>\n marked with \nVariableAttribute\n takes care of most of your storage needs.\n\n\nHolder\n\n\nWrapper that allows the library to intraface with your data in \"managed\" way, it allows you to write the values to files or app settings via underlying implementations of \nISyncStorage\n and \nIAsyncStorage\n. Out of the box it can handle \nISettingsProvider\n as \nISyncStorage\n and \nIDataCache\n as \nIAsyncStorage\n.\n\n\nYour data is cached in memory and not read every time you request it.\n\n\nVariableAttribute\n\n\nAllows to define additional behaviour for your data.\n\n\n\n\nMemoryOnly\n\n\nStores the data only in memory always skipping both storage options.\n\n\n\n\n\n\nCustomKey\n\n\nBy default property's name is used as \nkey\n (file name or settings key), you can specify your own here.\n\n\n\n\n\n\nExpirationTime\n\n\nDefines for how long the data is valid. By default only supported in \nIDataCache\n, you will have to implement own \nISyncStorage\n in order to consume this setting there.",
            "title": "AppVariables"
        },
        {
            "location": "/app-variables/#appvariables",
            "text": "It's a higher level mechanism that uses  ISettingsProvider  and  IFileStorageProvider  to provide easy typed access to stored data.   Note: It's only meant for reference types, don't use simple types.   public class AppVariables : AppVariablesBase\n{\n    public AppVariables(ISettingsProvider settingsProvider, IDataCache dataCache = null) \n            : base(settingsProvider, dataCache)\n    {\n\n    }\n\n    public AppVariables(ISyncStorage syncStorage, IAsyncStorage asyncStorage = null) \n            : base(syncStorage, asyncStorage)\n    {\n\n    }\n\n    [Variable]\n    public Holder<TokenModel> TokenModel { get; set; }\n\n    [Variable]\n    public Holder<VideoLibrary> VideoLibrary { get; set; }\n}  Single property of type  Holder<T>  marked with  VariableAttribute  takes care of most of your storage needs.",
            "title": "AppVariables"
        },
        {
            "location": "/app-variables/#holder",
            "text": "Wrapper that allows the library to intraface with your data in \"managed\" way, it allows you to write the values to files or app settings via underlying implementations of  ISyncStorage  and  IAsyncStorage . Out of the box it can handle  ISettingsProvider  as  ISyncStorage  and  IDataCache  as  IAsyncStorage .  Your data is cached in memory and not read every time you request it.",
            "title": "Holder"
        },
        {
            "location": "/app-variables/#variableattribute",
            "text": "Allows to define additional behaviour for your data.   MemoryOnly  Stores the data only in memory always skipping both storage options.    CustomKey  By default property's name is used as  key  (file name or settings key), you can specify your own here.    ExpirationTime  Defines for how long the data is valid. By default only supported in  IDataCache , you will have to implement own  ISyncStorage  in order to consume this setting there.",
            "title": "VariableAttribute"
        }
    ]
}