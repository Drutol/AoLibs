{
    "docs": [
        {
            "location": "/",
            "text": "AoLibs\n\n\nSet of various libraries that I happened to write during my Xamarin adventures. They are devised mainly for my own use but I took an effort to properly document them so that my co-workers or any other people I happen to develop with had easier time using these goodies.\n\n\n\n\nNote\n\n\nI'm primarily developing on Android that's why Android side of thigs is better thought out and much richer than iOS counterpart. While all iOS thing should work they could certainly use an improvement.\n\n\n\n\nFeel free to use this code in whatever way you see fit.\n\n\nFeatures\n\n\nLibrary supports \niOS\n and \nAndroid\n projects. It's divided into three parts:\n\n\n\n\n AoLibs.Navigation\n\n\nProvides cross platform navigation solution.\n\n\n\n\n\n\n AoLibs.Adapters\n\n\nVarious adapters gathering features that require writing platform specific code.\n\n\n\n\n\n\n AoLibs.Utilities\n\n\nCompletly random things that I tend to use in my projects.\n\n\n\n\n\n\n\n\nDependencies\n\n\n\n\nInfo\n\n\nThese libraries are built using MvvmLight libraries.\nNewtonsoft.Json is used for JSON serialization.",
            "title": "Home"
        },
        {
            "location": "/#aolibs",
            "text": "Set of various libraries that I happened to write during my Xamarin adventures. They are devised mainly for my own use but I took an effort to properly document them so that my co-workers or any other people I happen to develop with had easier time using these goodies.   Note  I'm primarily developing on Android that's why Android side of thigs is better thought out and much richer than iOS counterpart. While all iOS thing should work they could certainly use an improvement.   Feel free to use this code in whatever way you see fit.",
            "title": "AoLibs"
        },
        {
            "location": "/#features",
            "text": "Library supports  iOS  and  Android  projects. It's divided into three parts:    AoLibs.Navigation  Provides cross platform navigation solution.     AoLibs.Adapters  Various adapters gathering features that require writing platform specific code.     AoLibs.Utilities  Completly random things that I tend to use in my projects.",
            "title": "Features"
        },
        {
            "location": "/#dependencies",
            "text": "Info  These libraries are built using MvvmLight libraries.\nNewtonsoft.Json is used for JSON serialization.",
            "title": "Dependencies"
        },
        {
            "location": "/installation/",
            "text": "TODO",
            "title": "Installation"
        },
        {
            "location": "/installation/#todo",
            "text": "",
            "title": "TODO"
        },
        {
            "location": "/about/",
            "text": "About\n\n\nWelcome to About page! Nothing really important here...\n\n\n\n\nInfo\n\n\nIf you are curious about the origin of AoLibs... well that's because I really like this kanji which happen to read like \"Ao\"\n\n\n\u84bc\n\n\nIt means \"blue\"... but can also mean \"green\"... strange right? Hence the theme of upper header bar. From blue to green ^^ Japanese is for sure strange language.\n\n\n\n\nAuthors\n\n\nThere's only 1 to be honest. Check out my GitHub account if you want to get in touch!\n\n\nRelated projects\n\n\nTo be announced, there are 2 currently in development.",
            "title": "About"
        },
        {
            "location": "/about/#about",
            "text": "Welcome to About page! Nothing really important here...   Info  If you are curious about the origin of AoLibs... well that's because I really like this kanji which happen to read like \"Ao\"  \u84bc  It means \"blue\"... but can also mean \"green\"... strange right? Hence the theme of upper header bar. From blue to green ^^ Japanese is for sure strange language.",
            "title": "About"
        },
        {
            "location": "/about/#authors",
            "text": "There's only 1 to be honest. Check out my GitHub account if you want to get in touch!",
            "title": "Authors"
        },
        {
            "location": "/about/#related-projects",
            "text": "To be announced, there are 2 currently in development.",
            "title": "Related projects"
        },
        {
            "location": "/navigation/",
            "text": "Navigation\n\n\nThe goal is to provide lightweight solution for cross-platform navigation.\n\n\nThe main interface you will be using in your shared codebase is \nINavigationManager<TPageIdentifier>\n where \nTPageIdentifier\n is usally a simple enum with all your pages.\n\n\n\n\nBelow I'll descibe shared concepts between Android&iOS. Setup and platofrm specific things are contained in separate pages.\n\n\n\n\nPage providers\n\n\nThe page definitions dictionary takes in pair of \nTPageIdentifier\n which is simple \nenum\n in most cases and instance of class that implements \nIPageProvider<INavigationPage>\n. There are two implemented as of now:\n\n\n\n\nCachedPageProvider\n\n\nThis provider preserves the state of its page so that when we navigate there it will look the same.\n\n\n\n\n\n\nOneshotPageProvider\n\n\nHere we are providing the page instance just once, each navigation will create new uninitilized page. The use-case of it is to avoid manually cleaning pages like \nRegisterPage\n. I suggest disabling cache in your IoC container for associated ViewModel.\n\n\n\n\n\n\n\n\nNavigation lifecycle events\n\n\nINavigationPage\n provides following events for you to override from platform specific class:\n\n\npublic virtual void NavigatedTo();\npublic virtual void NavigatedBack();\npublic virtual void NavigatedFrom();\n\n\n\n\n\n\nNavigatedTo\n\n\nIs called when we navigate forward to this fragment.\n\n\neg. SignInPage -> DashboardPage\n\n\nDashboardPage invokes \nNavigatedTo\n\n\n\n\n\n\n\n\n\n\nNavigatedBack\n\n\nCalled when we navigate backwards to the page we have alraedy been on.\n\n\neg. SignInPage <- DashboardPage\n\n\nSignInPage invokes \nNavigatedBack\n\n\n\n\n\n\n\n\n\n\nNavigatedFrom\n\n\nIs called whenever we leave the page.\n\n\n\n\n\n\n\n\nNavigation with arguments\n\n\nIt's possible to invoke navigation with arguments. It allows us to separate ViewModels and avoid communication spaghetti code. \n\n\nINavigationManager<TPageIdentifier>\n allows to pass \nargs\n parameter which is plain \nSystem.Object\n. These arguments will appear in \nNavigationArguments\n property within fragment class.\n\n\nNavigation backstack options\n\n\nThere are defined following naviagtion options:\n\n\npublic enum NavigationBackstackOption\n{\n    AddToBackstack,\n    SetAsRootPage,\n    ClearBackstackToFirstOccurence,\n    NoBackstack,\n    ForceNewPageInstance\n}\n\n\n\n\n\n\nAddToBackstack\n\n\nBasic default option, current page will be added to backstack when navigating.\n\n\n\n\n\n\nSetAsRootPage\n\n\nClears backstack and then navigates to given page essentially making it a root page.\n\n\n\n\n\n\nClearBackstackToFirstOccurence\n\n\nAllows to \"jump\" to page that is already on backstack, let's say you have registration process consisting of multiple pages and once you are done you need to get back to \"Sign in\" page, with this option you can go back multiple pages.\n\n\n\n\n\n\nNoBackstack\n\n\nCurrent page won't be added to backstack on navigation.\n\n\n\n\n\n\nForceNewPageInstance\n\n\nRequests \nIPageProvider\n to recreate page instance before navigating.",
            "title": "Navigation"
        },
        {
            "location": "/navigation/#navigation",
            "text": "The goal is to provide lightweight solution for cross-platform navigation.  The main interface you will be using in your shared codebase is  INavigationManager<TPageIdentifier>  where  TPageIdentifier  is usally a simple enum with all your pages.   Below I'll descibe shared concepts between Android&iOS. Setup and platofrm specific things are contained in separate pages.",
            "title": "Navigation"
        },
        {
            "location": "/navigation/#page-providers",
            "text": "The page definitions dictionary takes in pair of  TPageIdentifier  which is simple  enum  in most cases and instance of class that implements  IPageProvider<INavigationPage> . There are two implemented as of now:   CachedPageProvider  This provider preserves the state of its page so that when we navigate there it will look the same.    OneshotPageProvider  Here we are providing the page instance just once, each navigation will create new uninitilized page. The use-case of it is to avoid manually cleaning pages like  RegisterPage . I suggest disabling cache in your IoC container for associated ViewModel.",
            "title": "Page providers"
        },
        {
            "location": "/navigation/#navigation-lifecycle-events",
            "text": "INavigationPage  provides following events for you to override from platform specific class:  public virtual void NavigatedTo();\npublic virtual void NavigatedBack();\npublic virtual void NavigatedFrom();   NavigatedTo  Is called when we navigate forward to this fragment.  eg. SignInPage -> DashboardPage  DashboardPage invokes  NavigatedTo      NavigatedBack  Called when we navigate backwards to the page we have alraedy been on.  eg. SignInPage <- DashboardPage  SignInPage invokes  NavigatedBack      NavigatedFrom  Is called whenever we leave the page.",
            "title": "Navigation lifecycle events"
        },
        {
            "location": "/navigation/#navigation-with-arguments",
            "text": "It's possible to invoke navigation with arguments. It allows us to separate ViewModels and avoid communication spaghetti code.   INavigationManager<TPageIdentifier>  allows to pass  args  parameter which is plain  System.Object . These arguments will appear in  NavigationArguments  property within fragment class.",
            "title": "Navigation with arguments"
        },
        {
            "location": "/navigation/#navigation-backstack-options",
            "text": "There are defined following naviagtion options:  public enum NavigationBackstackOption\n{\n    AddToBackstack,\n    SetAsRootPage,\n    ClearBackstackToFirstOccurence,\n    NoBackstack,\n    ForceNewPageInstance\n}   AddToBackstack  Basic default option, current page will be added to backstack when navigating.    SetAsRootPage  Clears backstack and then navigates to given page essentially making it a root page.    ClearBackstackToFirstOccurence  Allows to \"jump\" to page that is already on backstack, let's say you have registration process consisting of multiple pages and once you are done you need to get back to \"Sign in\" page, with this option you can go back multiple pages.    NoBackstack  Current page won't be added to backstack on navigation.    ForceNewPageInstance  Requests  IPageProvider  to recreate page instance before navigating.",
            "title": "Navigation backstack options"
        },
        {
            "location": "/navigation-android/",
            "text": "Introduction\n\n\nThe idea behind this navigation mechanism is simillar to how WPF/UWP's \n<Frame>\n element works. Namely we are have one root page that hosts all other pages. These pages are managed by libary within this frame.\n\n\nSetup\n\n\nAll pages are hosted as \nFragments\n, I'm assuming using single activity pattern.\nGiven a single android activity with layout:\n\n\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n              android:layout_width=\"match_parent\"\n              android:layout_height=\"match_parent\"\n              android:orientation=\"vertical\">\n\n  <FrameLayout android:layout_width=\"match_parent\"\n               android:layout_height=\"match_parent\"\n               android:id=\"@+id/RootView\" />\n</LinearLayout>\n\n\n\n\nNow we will want to initialize library from code.\nThe \nRootView\n \nFrameLayout\n will be hosting all our pages within itself.\n\n\nprotected override void OnCreate(Bundle savedInstanceState)\n{\n    base.OnCreate(savedInstanceState);\n\n    SetContentView(Resource.Layout.main);\n\n    var pageDefinitions = new Dictionary<PageIndex, IPageProvider<NavigationFragmentBase>>\n    {\n        // cached\n        {PageIndex.WelcomePage, new CachedPageProvider<WelcomePageFragment>()},\n        // oneshots\n        {PageIndex.SignInPage, new OneshotPageProvider<SignInPageFragment>()},\n    };\n\n    var manager = new NavigationManager<PageIndex>(\n        fragmentManager: SupportFragmentManager,\n        rootFrame: RootView,\n        pageDefinitions: pageDefinitions)\n}\n\n\n\n\nNow we can happily use our \nINavigationManager<TPageIdentifier>\n in our ViewModels!\n\n\nAdditional configuration\n\n\nAdding new pages\n\n\nAs we can see there are two pages defined \nWelcomePageFragment\n and \nSignInPageFragment\n. I'm providing base clases for fragments so it's very easy to add new content.\n\n\nType hierarchy:\n\n\n\n\n\n\nINavigationPage\n\n\n\n\n\n\nNavigationFragmentBase\n\n\n\n\nFragmentBase<TViewModel>\n\n\n\n\n\n\n\n\n\n\n\n\nNavigationFragmentBase\n inherits from Andoroid's \nFragment\n class and wraps its functionality. Let's say we want to create new page \nSplashPage\n.\n1. Create new class called for example \nSplashPageFragment\n\n2. Make it inherit from \nFragmentBase<TViewModel>\n\n\npublic class SplashPageFragment : FragmentBase<SplashViewModel>\n{\n    public override int LayoutResourceId { get; } = Resource.Layout.splash_page;\n\n    protected override void InitBindings()\n    {\n\n    }\n}\n\n\n\n\n\n\nThere are 2 required elements:\n\n\nLayoutResourceId\n which indicates which layout the fragment is associated with.\n\n\nInitBinings\n method in which we will define our bindings to ViewModel.\n\n\nAdd new entry in \npageDefinitions\n\n\n\n\nTransition animations\n\n\nIf you want to include transition animations when navigating you will want to use \nAction<FragmentTransaction> interceptTransaction\n parameter of \nNavigationManager\n's constructor. It will expose \nFragmentTransaction\n so you change whatever you want before actually commiting new page. For example:\n\n\nprivate void InterceptTransaction(FragmentTransaction fragmentTransaction)\n{\n    fragmentTransaction.SetCustomAnimations(\n        Resource.Animator.animation_slide_bottom,\n        Resource.Animator.animation_fade_out);\n}\n\n\n\n\nViewModel injection\n\n\nThe generic parameter of \nFragmentBase<TViewModel>\n allows you to specify which ViewModel to pull for given fragment. ViewModel will be available in \nViewModel\n property in your fragment.\nThis requires providing implementation of \nIViewModelResolver\n interface which will pull appropriate ViewModels from your IoC for example.\n\n\nprivate class ViewModelResolver : IViewModelResolver\n{\n    public TViewModel Resolve<TViewModel>()\n    {\n        using (var scope = ViewModelLocator.ObtainScope())\n        {\n            return scope.Resolve<TViewModel>();\n        }\n    }\n}\n\n\n\n\nThis \nViewModelResolver\n can be assigned to static property found on \nNavigationFragmentBase\n.\n\n\nNavigationFragmentBase.ViewModelResolver = new ViewModelResolver();\n\n\n\n\nBindings\n\n\nWhen we are talking navigation we are talking bindings lifecycle too. \nFragmentBase\n class handles them too. Since the library is based on MVVMLight library we are using its bindings. \n\n\nYou will want to add all of them to \nBindings\n which is of type \nList<Binding>\n, they will be properly attached and reattached when needed.\n\n\nYou are supposed to add all your bindings in \nInitBindings\n method which is called once per fragment instance or when bindigs need to be recreated.\n\n\nIf you don't have any bindings added to \nBindings\n, yet you don't wat the method to be fired again you can call this constructor:\n\n\npublic NavigationFragmentBase(bool hasNonTrackableBindings = false);\n\n\n\n\nExample:\n\n\nprotected override void InitBindings()\n{\n    Bindings.Add(this.SetBinding(() => ViewModel.Toggle).WhenSourceChanges(() =>\n    {\n        ToggleValue.Text = ViewModel.Toggle ? \"ON\" : \"OFF\";\n    }));\n\n    Bindings.Add(this.SetBinding(() => ViewModel.Value, () => Value.Text));\n}\n\n\n\n\nDisclaimer: \nValue\n and \nToggleValue\n are \nTextViews\n.\n\n\nNotes\n\n\n\n\nThe \nMainActivity\n will have to inherit \nAppCompatActivity\n.",
            "title": "Android Navigation"
        },
        {
            "location": "/navigation-android/#introduction",
            "text": "The idea behind this navigation mechanism is simillar to how WPF/UWP's  <Frame>  element works. Namely we are have one root page that hosts all other pages. These pages are managed by libary within this frame.",
            "title": "Introduction"
        },
        {
            "location": "/navigation-android/#setup",
            "text": "All pages are hosted as  Fragments , I'm assuming using single activity pattern.\nGiven a single android activity with layout:  <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n              android:layout_width=\"match_parent\"\n              android:layout_height=\"match_parent\"\n              android:orientation=\"vertical\">\n\n  <FrameLayout android:layout_width=\"match_parent\"\n               android:layout_height=\"match_parent\"\n               android:id=\"@+id/RootView\" />\n</LinearLayout>  Now we will want to initialize library from code.\nThe  RootView   FrameLayout  will be hosting all our pages within itself.  protected override void OnCreate(Bundle savedInstanceState)\n{\n    base.OnCreate(savedInstanceState);\n\n    SetContentView(Resource.Layout.main);\n\n    var pageDefinitions = new Dictionary<PageIndex, IPageProvider<NavigationFragmentBase>>\n    {\n        // cached\n        {PageIndex.WelcomePage, new CachedPageProvider<WelcomePageFragment>()},\n        // oneshots\n        {PageIndex.SignInPage, new OneshotPageProvider<SignInPageFragment>()},\n    };\n\n    var manager = new NavigationManager<PageIndex>(\n        fragmentManager: SupportFragmentManager,\n        rootFrame: RootView,\n        pageDefinitions: pageDefinitions)\n}  Now we can happily use our  INavigationManager<TPageIdentifier>  in our ViewModels!",
            "title": "Setup"
        },
        {
            "location": "/navigation-android/#additional-configuration",
            "text": "",
            "title": "Additional configuration"
        },
        {
            "location": "/navigation-android/#adding-new-pages",
            "text": "As we can see there are two pages defined  WelcomePageFragment  and  SignInPageFragment . I'm providing base clases for fragments so it's very easy to add new content.  Type hierarchy:    INavigationPage    NavigationFragmentBase   FragmentBase<TViewModel>       NavigationFragmentBase  inherits from Andoroid's  Fragment  class and wraps its functionality. Let's say we want to create new page  SplashPage .\n1. Create new class called for example  SplashPageFragment \n2. Make it inherit from  FragmentBase<TViewModel>  public class SplashPageFragment : FragmentBase<SplashViewModel>\n{\n    public override int LayoutResourceId { get; } = Resource.Layout.splash_page;\n\n    protected override void InitBindings()\n    {\n\n    }\n}   There are 2 required elements:  LayoutResourceId  which indicates which layout the fragment is associated with.  InitBinings  method in which we will define our bindings to ViewModel.  Add new entry in  pageDefinitions",
            "title": "Adding new pages"
        },
        {
            "location": "/navigation-android/#transition-animations",
            "text": "If you want to include transition animations when navigating you will want to use  Action<FragmentTransaction> interceptTransaction  parameter of  NavigationManager 's constructor. It will expose  FragmentTransaction  so you change whatever you want before actually commiting new page. For example:  private void InterceptTransaction(FragmentTransaction fragmentTransaction)\n{\n    fragmentTransaction.SetCustomAnimations(\n        Resource.Animator.animation_slide_bottom,\n        Resource.Animator.animation_fade_out);\n}",
            "title": "Transition animations"
        },
        {
            "location": "/navigation-android/#viewmodel-injection",
            "text": "The generic parameter of  FragmentBase<TViewModel>  allows you to specify which ViewModel to pull for given fragment. ViewModel will be available in  ViewModel  property in your fragment.\nThis requires providing implementation of  IViewModelResolver  interface which will pull appropriate ViewModels from your IoC for example.  private class ViewModelResolver : IViewModelResolver\n{\n    public TViewModel Resolve<TViewModel>()\n    {\n        using (var scope = ViewModelLocator.ObtainScope())\n        {\n            return scope.Resolve<TViewModel>();\n        }\n    }\n}  This  ViewModelResolver  can be assigned to static property found on  NavigationFragmentBase .  NavigationFragmentBase.ViewModelResolver = new ViewModelResolver();",
            "title": "ViewModel injection"
        },
        {
            "location": "/navigation-android/#bindings",
            "text": "When we are talking navigation we are talking bindings lifecycle too.  FragmentBase  class handles them too. Since the library is based on MVVMLight library we are using its bindings.   You will want to add all of them to  Bindings  which is of type  List<Binding> , they will be properly attached and reattached when needed.  You are supposed to add all your bindings in  InitBindings  method which is called once per fragment instance or when bindigs need to be recreated.  If you don't have any bindings added to  Bindings , yet you don't wat the method to be fired again you can call this constructor:  public NavigationFragmentBase(bool hasNonTrackableBindings = false);  Example:  protected override void InitBindings()\n{\n    Bindings.Add(this.SetBinding(() => ViewModel.Toggle).WhenSourceChanges(() =>\n    {\n        ToggleValue.Text = ViewModel.Toggle ? \"ON\" : \"OFF\";\n    }));\n\n    Bindings.Add(this.SetBinding(() => ViewModel.Value, () => Value.Text));\n}  Disclaimer:  Value  and  ToggleValue  are  TextViews .",
            "title": "Bindings"
        },
        {
            "location": "/navigation-android/#notes",
            "text": "The  MainActivity  will have to inherit  AppCompatActivity .",
            "title": "Notes"
        },
        {
            "location": "/navigation-ios/",
            "text": "iOS Navigation\n\n\nIntroduction\n\n\nIt was certainly a challenge to bend native iOS navigation to match with overall concept and Android's capabilities. Finally I have achieved the freedom of managing the naviagrion stack however I see fit from shared code.\n\n\nTodo",
            "title": "iOS Navigation"
        },
        {
            "location": "/navigation-ios/#ios-navigation",
            "text": "",
            "title": "iOS Navigation"
        },
        {
            "location": "/navigation-ios/#introduction",
            "text": "It was certainly a challenge to bend native iOS navigation to match with overall concept and Android's capabilities. Finally I have achieved the freedom of managing the naviagrion stack however I see fit from shared code.",
            "title": "Introduction"
        },
        {
            "location": "/navigation-ios/#todo",
            "text": "",
            "title": "Todo"
        },
        {
            "location": "/adapters/",
            "text": "Adapters\n\n\nThe library comes packed with quite a few adapters that will help you avoid writing boilerplate code for platfrom dependednt functionalities.\n\n\n\n\nAdapter is a class which provides same functionality that has to be implemented differently on different platforms.\n\n\n\n\nProvided adapters\n\n\nMain interfaces which can be used in shared codebase are found in \nAoLibs.Adapters.Core\n.\n\n\n\n\nIClipboardProvider\n\n\nIDataCache\n\n\nIDispatcherAdapter\n\n\nIFileStorageProvider\n\n\nILifecycleInfoProvider\n\n\nIMessageBoxProvider\n\n\nIPhoneCallAdapter\n\n\nIPhotoPickerAdapter\n\n\nIPickerAdapter\n\n\nISettingsProvider\n\n\nIUriLauncherAdapter\n\n\nIVersionProvider\n\n\n\n\nI'll provide more details on the ones that may be not obvious.\n\n\nDataCache\n\n\nIt depends on \nIFileStorageProvider\n. Uses Json.NET to serialize given data and save it to file for storage. Object are wrapped in object with timestamp so it's possible to specify for how long this piece of data stays valid.\n\n\nDispatcherAdapter\n\n\nRuns action on UI thread... that's it.\n\n\nLifecycleInfoProvider\n\n\nRequires manual invocation of methods.\n\n\nSettingsProvider\n\n\nProvides set of methods allowing to storage data in application's settings construct.",
            "title": "Adapters"
        },
        {
            "location": "/adapters/#adapters",
            "text": "The library comes packed with quite a few adapters that will help you avoid writing boilerplate code for platfrom dependednt functionalities.   Adapter is a class which provides same functionality that has to be implemented differently on different platforms.",
            "title": "Adapters"
        },
        {
            "location": "/adapters/#provided-adapters",
            "text": "Main interfaces which can be used in shared codebase are found in  AoLibs.Adapters.Core .   IClipboardProvider  IDataCache  IDispatcherAdapter  IFileStorageProvider  ILifecycleInfoProvider  IMessageBoxProvider  IPhoneCallAdapter  IPhotoPickerAdapter  IPickerAdapter  ISettingsProvider  IUriLauncherAdapter  IVersionProvider   I'll provide more details on the ones that may be not obvious.",
            "title": "Provided adapters"
        },
        {
            "location": "/adapters/#datacache",
            "text": "It depends on  IFileStorageProvider . Uses Json.NET to serialize given data and save it to file for storage. Object are wrapped in object with timestamp so it's possible to specify for how long this piece of data stays valid.",
            "title": "DataCache"
        },
        {
            "location": "/adapters/#dispatcheradapter",
            "text": "Runs action on UI thread... that's it.",
            "title": "DispatcherAdapter"
        },
        {
            "location": "/adapters/#lifecycleinfoprovider",
            "text": "Requires manual invocation of methods.",
            "title": "LifecycleInfoProvider"
        },
        {
            "location": "/adapters/#settingsprovider",
            "text": "Provides set of methods allowing to storage data in application's settings construct.",
            "title": "SettingsProvider"
        },
        {
            "location": "/adapters-android/",
            "text": "TODO",
            "title": "Android Adapters"
        },
        {
            "location": "/adapters-android/#todo",
            "text": "",
            "title": "TODO"
        },
        {
            "location": "/android-recycler-adapters/",
            "text": "Recycler View Adapters\n\n\nAdapters library contains set of adapters that eliminate need for creating custom adapter classes.\n\n\nApplicable types:\n\n\nAdapters:\n\n\n\n\nObservableRecyclerAdapter<TItem, THolder>\n\n\nObservableRecyclerAdapterWithFooter<TItem, THolder, TFooterHolder>\n\n\nObservableRecyclerAdapterWithMultipleViewTypes<TItemBase, THolder>\n\n\nObservableRecyclerAdapterWithMultipleViewTypesAndFooter<TItemBase, THolder, TFooterHolder>\n\n\n\n\nViewHolder:\n\n\n\n\nBindingViewHolderBase<T>\n\n\n\n\nUtilities:\n\n\n\n\n\n\nItemEntry\n\n\n\n\n\n\nSpecializedItemEntry<TSpecializedItem, TSpecializedHolder>\n\n\n\n\n\n\nThese classes provide an easy way to quickly implement recycler views for various scenarios starting from simple list to elaborate lists with various ViewModel bound elements with different layouts. All of provided adapters are utilising events of \nObservableCollection<T>\n.\n\n\nThe \nObservableRecyclerAdapter<TItem, THolder>\n is base class for all other specialized adapters.\n\n\nSimple setup\n\n\nSo let's say we want to set-up simple recycler view list. Let's assume we have layout already created with \nRecyclerView\n named \nRecyclerView\n\n\nRecyclerView.SetAdapter(\n    adapter: new ObservableRecyclerAdapter<Item, ItemViewHolder>(\n        items: ViewModel.Items, \n        dataTemplate: DataTemplate,\n        itemTemplate: ItemTemplate,\n        holderFactory: HolderFactory));\n\nprivate void DataTemplate(Item item, ItemViewHolder holder, int position)\n{\n    holder.SomeTextView.Text = item.SomeTextValue;\n}\n\nprivate View ItemTemplate(int viewType)\n{\n    return LayoutInflater.Inflate(Resource.Layout.some_item_layout, null);\n}\n\nprivate ItemViewHolder HolderFactory(ViewGroup parent, int viewType, View view)\n{\n    return new ItemViewHolder(view);\n}\n\n\n\n\nWe have 3 methods being passed to adapter's constructor:\n\n\n\n\nDataTemplate\n\n\nHere we are defining how to display given item in the list, you will receive current item and holder that will have to display it.\n\n\n\n\n\n\nItemTemplate\n\n\nHere you should provide view that will be later bound to view holder.\n\n\n\n\n\n\nHolderFactory\n\n\nHere we are instantinating holder for our virtualised items. This parameter is optional if your holder has public parameterless constructor and you don't need custom instantination.\n\n\n\n\n\n\n\n\nView Stretching\n\n\nUnless specified the views in \nRecyclerView\n won't stretch horizontally. I've provided simple utility that takes care of it. \n\n\nRecyclerView.SetAdapter(\n    adapter: new ObservableRecyclerAdapter<Item, ItemViewHolder>(\n        items: ViewModel.Items, \n        dataTemplate: DataTemplate,\n        itemTemplate: ItemTemplate,\n        holderFactory: HolderFactory) {ApplyLayoutParams = true});\n\n\n\n\nIn order to use it you just have to set \nApplyLayoutParams\n property to \ntrue\n. Item containers will be assigned with proper \nRecyclerView.LayoutParams\n after inflating.\n\n\nFooter\n\n\nAdapter with footer is very similar to standard adapter:\n\n\nRecyclerView.SetAdapter(\n    new ObservableRecyclerAdapterWithFooter<Item, ItemViewHolder, FooterHolder>(\n            items: ViewModel.Items, \n            dataTemplate: DataTemplate, \n            holderFactory: HolderFactory, \n            itemTemplate: ItemTemplate,\n            footerDataTemplate: FooterDataTemplate,\n            footerFactory: FooterFactory,\n            footerTemplate: FooterTemplate)\n        {ApplyLayoutParams = true});\n\n...\n\nprivate View FooterTemplate(int viewType)\n{\n    return LayoutInflater.Inflate(Resource.Layout.some_footer, null);\n}\n\nprivate FooterHolder FooterFactory(ViewGroup parent, int viewType, View view)\n{\n    return new FooterHolder(view);\n}\n\nprivate void FooterDataTemplate(Item item, FooterHolder holder, int position)\n{\n    holder.ViewModel = ViewModel;\n}\n\n\n\n\nAll you have to do is to add 3 more delegates defining footer. Mind you that \nitem\n argument in \nFooterDataTemplate\n is \nnull\n as there's no item applicable for that position.\n\n\n\n\nNote: If your footer holder inherits from \nBindingViewHolderBase<TViewModel>\n the holder won't automatically update bindings, you have to assign your ViewModel manually to footer.\n\n\n\n\nBinding ViewHolders\n\n\nAs I've previously mentioned it's possbile to easily implement bindings for each list entry.\nAll you have to do is to make your ViewHolder inherit from \nBindingViewHolderBase<TViewModel>\n.\nFor exmaple:\n\n\nprivate class SomeHolder : BindingViewHolderBase<SomeViewModel>\n{\n    private readonly View _view;\n\n    private TextView _totalPriceLabel;\n\n    public FooterHolder(View view) : base(view)\n    {\n        _view = view;\n    }\n\n    public TextView TotalPriceLabel => _totalPriceLabel ??\n                                       (_totalPriceLabel = _view.FindViewById<TextView>(Resource.Id.TotalPriceLabel));\n\n    protected override void SetBindings()\n    {\n        Bindings.Add(this.SetBinding(() => ViewModel.TotalOrderPrice, () => TotalPriceLabel.Text)\n            .ConvertSourceToTarget(arg => arg.ToString(\"C\")));\n    }\n}\n\n\n\n\nThis view holder will make you implement \nSetBindings\n methods which works exactly the same as in Fragment's bindings. ViewModel swapping and bindings detaching will all be handled by the library.\n\n\nAdapters with multiple view types\n\n\nThis is where the fun starts. We have this lovely class \nObservableRecyclerAdapterWithMultipleViewTypes<TItemBase, THolder>\n which is inheriting from \nObservableRecyclerAdapter<TItemBase,THolder>\n.\nNotice that there's no longer \nTItem\n but \nTItemBase\n that means we will provide list of various elements. You can go for \nobject\n here but I encourage to make your models share same even empty interface for cleanliness sake. \n\n\nThe constructor has changed too: \nObservableRecyclerAdapterWithMultipleViewTypes(Dictionary<Type, IItemEntry> templates,IList<TItemBase> items)\n we will have to provide a definition of view per item.\n\n\nRecyclerView.SetAdapter(\nnew ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem,\n        RecyclerView.ViewHolder>(\n        new Dictionary<Type, ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem,\n            RecyclerView.ViewHolder>.IItemEntry>\n        {\n            {\n                typeof(FriendListHeaderItem),\n                new ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem,\n                    RecyclerView.ViewHolder>.SpecializedItemEntry<FriendListHeaderItem,\n                    SectionViewHolder>\n                {\n                    SpecializedHolderFactory = HeaderHolderFactory,\n                    ItemTemplate = HeaderItemTemplate,\n                    SpecializedDataTemplate = HeaderDataTemplate\n                }\n            },\n            {\n                typeof(InviteFriendItemViewModel),\n                new ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem,\n                    RecyclerView.ViewHolder>.SpecializedItemEntry<InviteFriendItemViewModel,\n                    FriendViewHolder>\n                {\n                    SpecializedHolderFactory = ItemHolderFactory,\n                    ItemTemplate = ItemTemplate,\n                    SpecializedDataTemplate = ItemDataTemplate\n                }\n            }\n        }, ViewModel.Friends)\n    {ApplyLayoutParams = true});\n\n\n\n\nIt may look intimidating at first but it's not that bad. Essentially we are providing pairs of \nType\n and \nIItemEntry\n implementations that are found in the library.\n\n\nIFriendListItem\n is our \nTItemBase\n\n\nTViewHolder\n will usually be simple \nRecyclerView.ViewHolder\n\n\nLet's take a closer look on view-type definiton.\n\n\n{\n    typeof(InviteFriendItemViewModel),\n    new ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem,\n        RecyclerView.ViewHolder>.SpecializedItemEntry<InviteFriendItemViewModel,\n        FriendViewHolder>\n    {\n        SpecializedHolderFactory = ItemHolderFactory,\n        ItemTemplate = ItemTemplate,\n        SpecializedDataTemplate = ItemDataTemplate\n    }\n}\n\n\n\n\nFirst thing we provide is our concrete type that is contained within the items to display, easy enough.\nNow comes the second part, \nObservableRecyclerAdapterWithMultipleViewTypes\n has inner classes:\n\n\n\n\nSpecializedItemEntry\n\n\nItemEntry\n\nThey are used to define the views. \nSpecializedItemEntry\n is an evolution of \nItemEntry\n that handles type casting so we don't have to do it manually each time.\n\n\n\n\npublic class SpecializedItemEntry<TSpecializedItem, TSpecializedHolder> : IItemEntry\n    where TSpecializedItem : TItemBase\n    where TSpecializedHolder : THolder\n\n\n\n\nInstead of getting \nTItemBase\n and \nTHolder\n passed to our \nDataTemplate\n we will be getting solid instances of \nInviteFriendItemViewModel\n and \nFriendViewHolder\n. If you wish to do the casting manually you can use \nItemEntry\n.\n\n\n\n\nDon't use \nHolderFactory\n and \nDataTemplate\n properties in \nSpecializedItemEntry\n and use \nSpecializedHolderFactory\n and \nSpecializedDataTemplate\n properties instead. Exception will be thrown otherwise.\n\n\n\n\n{\n    typeof(RestaurantPageMenuItemViewModel),\n    new ObservableRecyclerAdapterWithMultipleViewTypes<\n            RestaurantPageViewModel.IRestaurantMenuItem, RecyclerView.ViewHolder>.ItemEntry\n        {\n            ItemTemplate = MenuItemTemplate,\n            DataTemplate = MenuDataTemplate,\n            HolderFactory = MenuHolderFactory\n        }\n}\n\n\n\n\nOf course you can use your friend \nBindingViewHolderBase<TViewModel>\n to achieve bindings per list item too!\n\n\nAdapters with multiple view types and footer\n\n\nThe ultimate form, handles just like \nObservableRecyclerAdapterWithMultipleViewTypes\n with addition of 3 delegates like in \nObservableRecyclerAdapterWithFooter\n. \n\n\nRecyclerView.SetAdapter(\n    new ObservableRecyclerAdapterWithMultipleViewTypesAndFooter<ReceiptPresentPageViewModel.IReceiptItem\n        , RecyclerView.ViewHolder, FooterViewHolder>(\n        new Dictionary<Type, ObservableRecyclerAdapterWithMultipleViewTypes<\n            ReceiptPresentPageViewModel.IReceiptItem, RecyclerView.ViewHolder>.IItemEntry>\n        {\n            {\n                typeof(ReceiptHeaderItem),\n                new ObservableRecyclerAdapterWithMultipleViewTypes<\n                        ReceiptPresentPageViewModel.IReceiptItem, RecyclerView.ViewHolder>.\n                    SpecializedItemEntry<ReceiptHeaderItem, HeaderViewHolder>\n                    {\n                        SpecializedHolderFactory = HeaderHolderFactory,\n                        ItemTemplate = HeaderItemTemplate,\n                        SpecializedDataTemplate = HeaderDataTemplate\n                    }\n            },\n            {\n                typeof(ReceiptOrderedDishItemViewModel),\n                new ObservableRecyclerAdapterWithMultipleViewTypes<\n                        ReceiptPresentPageViewModel.IReceiptItem, RecyclerView.ViewHolder>.\n                    SpecializedItemEntry<ReceiptOrderedDishItemViewModel, OrderedDishViewHolder>\n                    {\n                        SpecializedHolderFactory = OrderedDishHolderFactory,\n                        ItemTemplate = OrderedDishItemTemplate,\n                        SpecializedDataTemplate = OrderedDishDataTemplate\n                    }\n            },\n            {\n                typeof(ReceiptOrderSectionFooterItem),\n                new ObservableRecyclerAdapterWithMultipleViewTypes<\n                        ReceiptPresentPageViewModel.IReceiptItem, RecyclerView.ViewHolder>.\n                    SpecializedItemEntry<ReceiptOrderSectionFooterItem, SectionFooterViewHolder>\n                    {\n                        SpecializedHolderFactory = SectionFooterHolderFactory,\n                        ItemTemplate = SectionFooterItemTemplate,\n                        SpecializedDataTemplate = SectionFooterDataTemplate\n                    }\n            }\n        }, \n        ViewModel.CurrentReceipt, \n        FooterDataTemplate, \n        FooterFactory, \n        FooterTemplate)\n    {\n        ApplyLayoutParams = true\n    });",
            "title": "Android Recycler Adapters"
        },
        {
            "location": "/android-recycler-adapters/#recycler-view-adapters",
            "text": "Adapters library contains set of adapters that eliminate need for creating custom adapter classes.  Applicable types:  Adapters:   ObservableRecyclerAdapter<TItem, THolder>  ObservableRecyclerAdapterWithFooter<TItem, THolder, TFooterHolder>  ObservableRecyclerAdapterWithMultipleViewTypes<TItemBase, THolder>  ObservableRecyclerAdapterWithMultipleViewTypesAndFooter<TItemBase, THolder, TFooterHolder>   ViewHolder:   BindingViewHolderBase<T>   Utilities:    ItemEntry    SpecializedItemEntry<TSpecializedItem, TSpecializedHolder>    These classes provide an easy way to quickly implement recycler views for various scenarios starting from simple list to elaborate lists with various ViewModel bound elements with different layouts. All of provided adapters are utilising events of  ObservableCollection<T> .  The  ObservableRecyclerAdapter<TItem, THolder>  is base class for all other specialized adapters.",
            "title": "Recycler View Adapters"
        },
        {
            "location": "/android-recycler-adapters/#simple-setup",
            "text": "So let's say we want to set-up simple recycler view list. Let's assume we have layout already created with  RecyclerView  named  RecyclerView  RecyclerView.SetAdapter(\n    adapter: new ObservableRecyclerAdapter<Item, ItemViewHolder>(\n        items: ViewModel.Items, \n        dataTemplate: DataTemplate,\n        itemTemplate: ItemTemplate,\n        holderFactory: HolderFactory));\n\nprivate void DataTemplate(Item item, ItemViewHolder holder, int position)\n{\n    holder.SomeTextView.Text = item.SomeTextValue;\n}\n\nprivate View ItemTemplate(int viewType)\n{\n    return LayoutInflater.Inflate(Resource.Layout.some_item_layout, null);\n}\n\nprivate ItemViewHolder HolderFactory(ViewGroup parent, int viewType, View view)\n{\n    return new ItemViewHolder(view);\n}  We have 3 methods being passed to adapter's constructor:   DataTemplate  Here we are defining how to display given item in the list, you will receive current item and holder that will have to display it.    ItemTemplate  Here you should provide view that will be later bound to view holder.    HolderFactory  Here we are instantinating holder for our virtualised items. This parameter is optional if your holder has public parameterless constructor and you don't need custom instantination.",
            "title": "Simple setup"
        },
        {
            "location": "/android-recycler-adapters/#view-stretching",
            "text": "Unless specified the views in  RecyclerView  won't stretch horizontally. I've provided simple utility that takes care of it.   RecyclerView.SetAdapter(\n    adapter: new ObservableRecyclerAdapter<Item, ItemViewHolder>(\n        items: ViewModel.Items, \n        dataTemplate: DataTemplate,\n        itemTemplate: ItemTemplate,\n        holderFactory: HolderFactory) {ApplyLayoutParams = true});  In order to use it you just have to set  ApplyLayoutParams  property to  true . Item containers will be assigned with proper  RecyclerView.LayoutParams  after inflating.",
            "title": "View Stretching"
        },
        {
            "location": "/android-recycler-adapters/#footer",
            "text": "Adapter with footer is very similar to standard adapter:  RecyclerView.SetAdapter(\n    new ObservableRecyclerAdapterWithFooter<Item, ItemViewHolder, FooterHolder>(\n            items: ViewModel.Items, \n            dataTemplate: DataTemplate, \n            holderFactory: HolderFactory, \n            itemTemplate: ItemTemplate,\n            footerDataTemplate: FooterDataTemplate,\n            footerFactory: FooterFactory,\n            footerTemplate: FooterTemplate)\n        {ApplyLayoutParams = true});\n\n...\n\nprivate View FooterTemplate(int viewType)\n{\n    return LayoutInflater.Inflate(Resource.Layout.some_footer, null);\n}\n\nprivate FooterHolder FooterFactory(ViewGroup parent, int viewType, View view)\n{\n    return new FooterHolder(view);\n}\n\nprivate void FooterDataTemplate(Item item, FooterHolder holder, int position)\n{\n    holder.ViewModel = ViewModel;\n}  All you have to do is to add 3 more delegates defining footer. Mind you that  item  argument in  FooterDataTemplate  is  null  as there's no item applicable for that position.   Note: If your footer holder inherits from  BindingViewHolderBase<TViewModel>  the holder won't automatically update bindings, you have to assign your ViewModel manually to footer.",
            "title": "Footer"
        },
        {
            "location": "/android-recycler-adapters/#binding-viewholders",
            "text": "As I've previously mentioned it's possbile to easily implement bindings for each list entry.\nAll you have to do is to make your ViewHolder inherit from  BindingViewHolderBase<TViewModel> .\nFor exmaple:  private class SomeHolder : BindingViewHolderBase<SomeViewModel>\n{\n    private readonly View _view;\n\n    private TextView _totalPriceLabel;\n\n    public FooterHolder(View view) : base(view)\n    {\n        _view = view;\n    }\n\n    public TextView TotalPriceLabel => _totalPriceLabel ??\n                                       (_totalPriceLabel = _view.FindViewById<TextView>(Resource.Id.TotalPriceLabel));\n\n    protected override void SetBindings()\n    {\n        Bindings.Add(this.SetBinding(() => ViewModel.TotalOrderPrice, () => TotalPriceLabel.Text)\n            .ConvertSourceToTarget(arg => arg.ToString(\"C\")));\n    }\n}  This view holder will make you implement  SetBindings  methods which works exactly the same as in Fragment's bindings. ViewModel swapping and bindings detaching will all be handled by the library.",
            "title": "Binding ViewHolders"
        },
        {
            "location": "/android-recycler-adapters/#adapters-with-multiple-view-types",
            "text": "This is where the fun starts. We have this lovely class  ObservableRecyclerAdapterWithMultipleViewTypes<TItemBase, THolder>  which is inheriting from  ObservableRecyclerAdapter<TItemBase,THolder> .\nNotice that there's no longer  TItem  but  TItemBase  that means we will provide list of various elements. You can go for  object  here but I encourage to make your models share same even empty interface for cleanliness sake.   The constructor has changed too:  ObservableRecyclerAdapterWithMultipleViewTypes(Dictionary<Type, IItemEntry> templates,IList<TItemBase> items)  we will have to provide a definition of view per item.  RecyclerView.SetAdapter(\nnew ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem,\n        RecyclerView.ViewHolder>(\n        new Dictionary<Type, ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem,\n            RecyclerView.ViewHolder>.IItemEntry>\n        {\n            {\n                typeof(FriendListHeaderItem),\n                new ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem,\n                    RecyclerView.ViewHolder>.SpecializedItemEntry<FriendListHeaderItem,\n                    SectionViewHolder>\n                {\n                    SpecializedHolderFactory = HeaderHolderFactory,\n                    ItemTemplate = HeaderItemTemplate,\n                    SpecializedDataTemplate = HeaderDataTemplate\n                }\n            },\n            {\n                typeof(InviteFriendItemViewModel),\n                new ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem,\n                    RecyclerView.ViewHolder>.SpecializedItemEntry<InviteFriendItemViewModel,\n                    FriendViewHolder>\n                {\n                    SpecializedHolderFactory = ItemHolderFactory,\n                    ItemTemplate = ItemTemplate,\n                    SpecializedDataTemplate = ItemDataTemplate\n                }\n            }\n        }, ViewModel.Friends)\n    {ApplyLayoutParams = true});  It may look intimidating at first but it's not that bad. Essentially we are providing pairs of  Type  and  IItemEntry  implementations that are found in the library.  IFriendListItem  is our  TItemBase  TViewHolder  will usually be simple  RecyclerView.ViewHolder  Let's take a closer look on view-type definiton.  {\n    typeof(InviteFriendItemViewModel),\n    new ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem,\n        RecyclerView.ViewHolder>.SpecializedItemEntry<InviteFriendItemViewModel,\n        FriendViewHolder>\n    {\n        SpecializedHolderFactory = ItemHolderFactory,\n        ItemTemplate = ItemTemplate,\n        SpecializedDataTemplate = ItemDataTemplate\n    }\n}  First thing we provide is our concrete type that is contained within the items to display, easy enough.\nNow comes the second part,  ObservableRecyclerAdapterWithMultipleViewTypes  has inner classes:   SpecializedItemEntry  ItemEntry \nThey are used to define the views.  SpecializedItemEntry  is an evolution of  ItemEntry  that handles type casting so we don't have to do it manually each time.   public class SpecializedItemEntry<TSpecializedItem, TSpecializedHolder> : IItemEntry\n    where TSpecializedItem : TItemBase\n    where TSpecializedHolder : THolder  Instead of getting  TItemBase  and  THolder  passed to our  DataTemplate  we will be getting solid instances of  InviteFriendItemViewModel  and  FriendViewHolder . If you wish to do the casting manually you can use  ItemEntry .   Don't use  HolderFactory  and  DataTemplate  properties in  SpecializedItemEntry  and use  SpecializedHolderFactory  and  SpecializedDataTemplate  properties instead. Exception will be thrown otherwise.   {\n    typeof(RestaurantPageMenuItemViewModel),\n    new ObservableRecyclerAdapterWithMultipleViewTypes<\n            RestaurantPageViewModel.IRestaurantMenuItem, RecyclerView.ViewHolder>.ItemEntry\n        {\n            ItemTemplate = MenuItemTemplate,\n            DataTemplate = MenuDataTemplate,\n            HolderFactory = MenuHolderFactory\n        }\n}  Of course you can use your friend  BindingViewHolderBase<TViewModel>  to achieve bindings per list item too!",
            "title": "Adapters with multiple view types"
        },
        {
            "location": "/android-recycler-adapters/#adapters-with-multiple-view-types-and-footer",
            "text": "The ultimate form, handles just like  ObservableRecyclerAdapterWithMultipleViewTypes  with addition of 3 delegates like in  ObservableRecyclerAdapterWithFooter .   RecyclerView.SetAdapter(\n    new ObservableRecyclerAdapterWithMultipleViewTypesAndFooter<ReceiptPresentPageViewModel.IReceiptItem\n        , RecyclerView.ViewHolder, FooterViewHolder>(\n        new Dictionary<Type, ObservableRecyclerAdapterWithMultipleViewTypes<\n            ReceiptPresentPageViewModel.IReceiptItem, RecyclerView.ViewHolder>.IItemEntry>\n        {\n            {\n                typeof(ReceiptHeaderItem),\n                new ObservableRecyclerAdapterWithMultipleViewTypes<\n                        ReceiptPresentPageViewModel.IReceiptItem, RecyclerView.ViewHolder>.\n                    SpecializedItemEntry<ReceiptHeaderItem, HeaderViewHolder>\n                    {\n                        SpecializedHolderFactory = HeaderHolderFactory,\n                        ItemTemplate = HeaderItemTemplate,\n                        SpecializedDataTemplate = HeaderDataTemplate\n                    }\n            },\n            {\n                typeof(ReceiptOrderedDishItemViewModel),\n                new ObservableRecyclerAdapterWithMultipleViewTypes<\n                        ReceiptPresentPageViewModel.IReceiptItem, RecyclerView.ViewHolder>.\n                    SpecializedItemEntry<ReceiptOrderedDishItemViewModel, OrderedDishViewHolder>\n                    {\n                        SpecializedHolderFactory = OrderedDishHolderFactory,\n                        ItemTemplate = OrderedDishItemTemplate,\n                        SpecializedDataTemplate = OrderedDishDataTemplate\n                    }\n            },\n            {\n                typeof(ReceiptOrderSectionFooterItem),\n                new ObservableRecyclerAdapterWithMultipleViewTypes<\n                        ReceiptPresentPageViewModel.IReceiptItem, RecyclerView.ViewHolder>.\n                    SpecializedItemEntry<ReceiptOrderSectionFooterItem, SectionFooterViewHolder>\n                    {\n                        SpecializedHolderFactory = SectionFooterHolderFactory,\n                        ItemTemplate = SectionFooterItemTemplate,\n                        SpecializedDataTemplate = SectionFooterDataTemplate\n                    }\n            }\n        }, \n        ViewModel.CurrentReceipt, \n        FooterDataTemplate, \n        FooterFactory, \n        FooterTemplate)\n    {\n        ApplyLayoutParams = true\n    });",
            "title": "Adapters with multiple view types and footer"
        },
        {
            "location": "/app-variables/",
            "text": "AppVariables\n\n\nIt's a higher level mechanism that uses \nISettingsProvider\n and \nIFileStorageProvider\n to provide easy typed access to stored data.\n\n\n\n\nNote: It's only meant for reference types, don't use simple types.\n\n\n\n\npublic class AppVariables : AppVariablesBase\n{\n    public AppVariables(ISettingsProvider settingsProvider, IDataCache dataCache = null) \n            : base(settingsProvider, dataCache)\n    {\n\n    }\n\n    public AppVariables(ISyncStorage syncStorage, IAsyncStorage asyncStorage = null) \n            : base(syncStorage, asyncStorage)\n    {\n\n    }\n\n    [Variable]\n    public Holder<TokenModel> TokenModel { get; set; }\n\n    [Variable]\n    public Holder<VideoLibrary> VideoLibrary { get; set; }\n}\n\n\n\n\nSingle property of type \nHolder<T>\n marked with \nVariableAttribute\n takes care of most of your storage needs.\n\n\nHolder\n\n\nWrapper that allows the library to intraface with your data in \"managed\" way, it allows you to write the values to files or app settings via underlying implementations of \nISyncStorage\n and \nIAsyncStorage\n. Out of the box it can handle \nISettingsProvider\n as \nISyncStorage\n and \nIDataCache\n as \nIAsyncStorage\n.\n\n\nYour data is cached in memory and not read every time you request it.\n\n\nVariableAttribute\n\n\nAllows to define additional behaviour for your data.\n\n\n\n\nMemoryOnly\n\n\nStores the data only in memory always skipping both storage options.\n\n\n\n\n\n\nCustomKey\n\n\nBy default property's name is used as \nkey\n (file name or settings key), you can specify your own here.\n\n\n\n\n\n\nExpirationTime\n\n\nDefines for how long the data is valid. By default only supported in \nIDataCache\n, you will have to implement own \nISyncStorage\n in order to consume this setting there.",
            "title": "AppVariables"
        },
        {
            "location": "/app-variables/#appvariables",
            "text": "It's a higher level mechanism that uses  ISettingsProvider  and  IFileStorageProvider  to provide easy typed access to stored data.   Note: It's only meant for reference types, don't use simple types.   public class AppVariables : AppVariablesBase\n{\n    public AppVariables(ISettingsProvider settingsProvider, IDataCache dataCache = null) \n            : base(settingsProvider, dataCache)\n    {\n\n    }\n\n    public AppVariables(ISyncStorage syncStorage, IAsyncStorage asyncStorage = null) \n            : base(syncStorage, asyncStorage)\n    {\n\n    }\n\n    [Variable]\n    public Holder<TokenModel> TokenModel { get; set; }\n\n    [Variable]\n    public Holder<VideoLibrary> VideoLibrary { get; set; }\n}  Single property of type  Holder<T>  marked with  VariableAttribute  takes care of most of your storage needs.",
            "title": "AppVariables"
        },
        {
            "location": "/app-variables/#holder",
            "text": "Wrapper that allows the library to intraface with your data in \"managed\" way, it allows you to write the values to files or app settings via underlying implementations of  ISyncStorage  and  IAsyncStorage . Out of the box it can handle  ISettingsProvider  as  ISyncStorage  and  IDataCache  as  IAsyncStorage .  Your data is cached in memory and not read every time you request it.",
            "title": "Holder"
        },
        {
            "location": "/app-variables/#variableattribute",
            "text": "Allows to define additional behaviour for your data.   MemoryOnly  Stores the data only in memory always skipping both storage options.    CustomKey  By default property's name is used as  key  (file name or settings key), you can specify your own here.    ExpirationTime  Defines for how long the data is valid. By default only supported in  IDataCache , you will have to implement own  ISyncStorage  in order to consume this setting there.",
            "title": "VariableAttribute"
        },
        {
            "location": "/utilities/",
            "text": "Utilities\n\n\nSet of various little helpers that I found useful.\n\n\nDateTimeExtensions\n\n\nDateTime DateTimeFromUnixTimestamp(this int timestamp)\n\n\nTakes epoch timestamp and converts it to \nDateTime\n object.\n\n\nint ToUnixTimestamp(this DateTime date)\n\n\nConverts \nDateTime\n to epoch integer.\n\n\nDiffUtility\n\n\nHelps diffing 2 collections. There are two extension methods for this utility:\n\n\n\n\nDiffResult<T> Diff<T>(this IEnumerable<T> first, IEnumerable<T> other, CompareDelegate<T> referenceComparer, IEqualityComparer<T> equalityComparer)\n\n\nYou can provide \nIEqualityComparer<T>\n that will be used to compare the items.\n\n\n\n\n\n\nDiffResult<T> Diff<T>(this IEnumerable<T> first, IEnumerable<T> other, CompareDelegate<T> referenceComparer, CompareDelegate<T> equalityComparer = null)\n\n\nIf you don't \nequalityComparer\n default \n.Equals()\n method will be utilised.\n\n\n\n\n\n\n\n\nArguments:\n\n\n\n\nfirst\n\n\nOriginal collection\n\n\n\n\n\n\nother\n\n\nAltered collection\n\n\n\n\n\n\nreferenceComparer\n\n\nDelegate that allows to differentiate same entities, you want to compare IDs here for example.\n\n\n\n\n\n\nequalityComparer\n\n\nIndicates whether the item differs in its contents from other.\n\n\n\n\n\n\n\n\nOn output you will receive \nDiffResult<T>\n object:\n\n\npublic class DiffResult<T>\n{\n    public IEnumerable<T> Added { get; internal set; }\n    public IEnumerable<T> Removed { get; internal set; }\n    public IEnumerable<T> Unmodified { get; internal set; }\n    public IEnumerable<T> Modified { get; internal set; }\n}   \n\n\n\n\nAll these operations defined in \nIEnumerable<T>\n are held back until they are enumerated.\n\n\nFileSizeUtility\n\n\nstring GetHumanReadableBytesLength(long value)\n\n\nTakes byte count and outputs proper size string.\nPossible suffixes:\n\n\nSizeSuffixes = {\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"};\n\n\n\n\nSmartObservableCollection\n\n\nExtension over \nObservableCollection<T>\n. The \nsmart\n part comes from addition of  \nvoid AddRange(IEnumerable<T> range)\n method. Proper collection changed events will be issued for newly added items only in a batch.\n\n\nStringExtensions\n\n\n\n\nstring FirstCharToUpper(this string input)\n\n\nstring FirstCharToLower(this string input)\n\n\nstring Wrap(this string s, string start, string end)\n\n\nstring TrimWhitespaceInside(this string str, bool allWhitespce = true)\n\n\nRemoves whitespace in the middle of the string, \nallWhitespace\n specifies if regex will be working with \n\\s\n or just \n\" \"\n.\n\n\n\n\n\n\n\n\nStringUtilities\n\n\nstatic int LevenshteinDistance(string s, string t)\n\n\nCalculates simple Levenshtein distance between given strings.",
            "title": "Utilities"
        },
        {
            "location": "/utilities/#utilities",
            "text": "Set of various little helpers that I found useful.",
            "title": "Utilities"
        },
        {
            "location": "/utilities/#datetimeextensions",
            "text": "DateTime DateTimeFromUnixTimestamp(this int timestamp)  Takes epoch timestamp and converts it to  DateTime  object.  int ToUnixTimestamp(this DateTime date)  Converts  DateTime  to epoch integer.",
            "title": "DateTimeExtensions"
        },
        {
            "location": "/utilities/#diffutility",
            "text": "Helps diffing 2 collections. There are two extension methods for this utility:   DiffResult<T> Diff<T>(this IEnumerable<T> first, IEnumerable<T> other, CompareDelegate<T> referenceComparer, IEqualityComparer<T> equalityComparer)  You can provide  IEqualityComparer<T>  that will be used to compare the items.    DiffResult<T> Diff<T>(this IEnumerable<T> first, IEnumerable<T> other, CompareDelegate<T> referenceComparer, CompareDelegate<T> equalityComparer = null)  If you don't  equalityComparer  default  .Equals()  method will be utilised.     Arguments:   first  Original collection    other  Altered collection    referenceComparer  Delegate that allows to differentiate same entities, you want to compare IDs here for example.    equalityComparer  Indicates whether the item differs in its contents from other.     On output you will receive  DiffResult<T>  object:  public class DiffResult<T>\n{\n    public IEnumerable<T> Added { get; internal set; }\n    public IEnumerable<T> Removed { get; internal set; }\n    public IEnumerable<T> Unmodified { get; internal set; }\n    public IEnumerable<T> Modified { get; internal set; }\n}     All these operations defined in  IEnumerable<T>  are held back until they are enumerated.",
            "title": "DiffUtility"
        },
        {
            "location": "/utilities/#filesizeutility",
            "text": "string GetHumanReadableBytesLength(long value)  Takes byte count and outputs proper size string.\nPossible suffixes:  SizeSuffixes = {\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"};",
            "title": "FileSizeUtility"
        },
        {
            "location": "/utilities/#smartobservablecollection",
            "text": "Extension over  ObservableCollection<T> . The  smart  part comes from addition of   void AddRange(IEnumerable<T> range)  method. Proper collection changed events will be issued for newly added items only in a batch.",
            "title": "SmartObservableCollection"
        },
        {
            "location": "/utilities/#stringextensions",
            "text": "string FirstCharToUpper(this string input)  string FirstCharToLower(this string input)  string Wrap(this string s, string start, string end)  string TrimWhitespaceInside(this string str, bool allWhitespce = true)  Removes whitespace in the middle of the string,  allWhitespace  specifies if regex will be working with  \\s  or just  \" \" .",
            "title": "StringExtensions"
        },
        {
            "location": "/utilities/#stringutilities",
            "text": "static int LevenshteinDistance(string s, string t)  Calculates simple Levenshtein distance between given strings.",
            "title": "StringUtilities"
        },
        {
            "location": "/utilities-android/",
            "text": "Android Utilities\n\n\nViews\n\n\n\n\nScrollableSwipeToRefreshLayout\n\n\nExtension to \nSwipeRefreshLayout\n, allows to specify View the has scrolling capabilities in \nScrollingView\n property. It will be later used to determine whether to or not allow refresh gesture. This gesture is only allowed while on the very top of the scrolling view.\n\n\nCanRefresh\n property will be used if \nSwipeRefreshLayout\n equals \nnull\n\n\n\n\n\n\n\n\nHelpers\n\n\n\n\nJavaObjectWrapper<T>\n\n\nSimple wrapper so that we can easily place purely C# classes withing \nTag\n property of \nView\n.\n\n\nGoes well with with provided extension methods:\n\n\nstatic T Unwrap<T>(this Java.Lang.Object obj)\n\n\nstatic JavaObjectWrapper<T> Wrap<T>(this T obj)\n\n\n\n\n\n\n\n\n\n\nDimensionsHelper\n\n\nConverts \ndp\n to \npx\n or \npx\n to \ndp\n\n\n\n\n\n\n\n\nCommands\n\n\nSet of 4 extension methods that help setting \nICommand\n for \nView\n:\n\n\n\n\nvoid SetOnClickCommand(this View view, ICommand command)\n\n\nvoid SetOnClickCommand(this View view, ICommand command, Action<View,bool> onCanExecuteChanged)\n\n\nvoid SetOnClickCommand(this View view, ICommand command, object arg)\n\n\nvoid SetOnClickCommand(this View view, ICommand command, object arg, Action<View, bool> onCanExecuteChanged)\n\n\n\n\nThese commands will subscribe to \nCanExecuteChanged\n event. By default \nEnabled\n property will be changed but you can also use overload with \nAction<View,bool> onCanExecuteChanged\n argument to customize behaviour. The other 2 variants allow passing \nobject arg\n argument to \nICommand\n's \nExecute()\n method.\n\n\nMemory watcher\n\n\nMemory on android is precious. \nMemoryWatcher\n singleton allows to alert when the free memory drops below given percentage.",
            "title": "Android Utilities"
        },
        {
            "location": "/utilities-android/#android-utilities",
            "text": "",
            "title": "Android Utilities"
        },
        {
            "location": "/utilities-android/#views",
            "text": "ScrollableSwipeToRefreshLayout  Extension to  SwipeRefreshLayout , allows to specify View the has scrolling capabilities in  ScrollingView  property. It will be later used to determine whether to or not allow refresh gesture. This gesture is only allowed while on the very top of the scrolling view.  CanRefresh  property will be used if  SwipeRefreshLayout  equals  null",
            "title": "Views"
        },
        {
            "location": "/utilities-android/#helpers",
            "text": "JavaObjectWrapper<T>  Simple wrapper so that we can easily place purely C# classes withing  Tag  property of  View .  Goes well with with provided extension methods:  static T Unwrap<T>(this Java.Lang.Object obj)  static JavaObjectWrapper<T> Wrap<T>(this T obj)      DimensionsHelper  Converts  dp  to  px  or  px  to  dp",
            "title": "Helpers"
        },
        {
            "location": "/utilities-android/#commands",
            "text": "Set of 4 extension methods that help setting  ICommand  for  View :   void SetOnClickCommand(this View view, ICommand command)  void SetOnClickCommand(this View view, ICommand command, Action<View,bool> onCanExecuteChanged)  void SetOnClickCommand(this View view, ICommand command, object arg)  void SetOnClickCommand(this View view, ICommand command, object arg, Action<View, bool> onCanExecuteChanged)   These commands will subscribe to  CanExecuteChanged  event. By default  Enabled  property will be changed but you can also use overload with  Action<View,bool> onCanExecuteChanged  argument to customize behaviour. The other 2 variants allow passing  object arg  argument to  ICommand 's  Execute()  method.",
            "title": "Commands"
        },
        {
            "location": "/utilities-android/#memory-watcher",
            "text": "Memory on android is precious.  MemoryWatcher  singleton allows to alert when the free memory drops below given percentage.",
            "title": "Memory watcher"
        },
        {
            "location": "/android-listeners/",
            "text": "Android Listeners\n\n\nSet of various listeners that are accepting delegates to native Android callback classes.\n\n\n\n\nDateSetListener : DatePickerDialog.IOnDateSetListener\n\n\nGenericMotionListener :  View.IOnGenericMotionListener\n\n\nOnCheckedListener : RadioGroup.IOnCheckedChangeListener\n\n\nOnClickListener : View.IOnClickListener\n\n\nOnEditorActionListener : TextView.IOnEditorActionListener\n\n\nOnItemClickListener<T> : AdapterView.IOnItemClickListener\n\n\nExpects the item to be wrapped with \nJavaObjectWrapper<T>\n withing \nTag\n property.\n\n\n\n\n\n\nOnLongClickListener : View.IOnLongClickListener\n\n\nOnScrollListener : AbsListView.IOnScrollListener\n\n\nOnTextEnterListener : ITextWatcher\n\n\nIf EditText can be multiline this listner will detect wheter the user presses \"Enter\" on their keyboard.\n\n\n\n\n\n\nOnTouchListener : View.IOnTouchListener\n\n\nScrollListener : AbsListView.IOnScrollChangeListener",
            "title": "Android Listeners"
        },
        {
            "location": "/android-listeners/#android-listeners",
            "text": "Set of various listeners that are accepting delegates to native Android callback classes.   DateSetListener : DatePickerDialog.IOnDateSetListener  GenericMotionListener :  View.IOnGenericMotionListener  OnCheckedListener : RadioGroup.IOnCheckedChangeListener  OnClickListener : View.IOnClickListener  OnEditorActionListener : TextView.IOnEditorActionListener  OnItemClickListener<T> : AdapterView.IOnItemClickListener  Expects the item to be wrapped with  JavaObjectWrapper<T>  withing  Tag  property.    OnLongClickListener : View.IOnLongClickListener  OnScrollListener : AbsListView.IOnScrollListener  OnTextEnterListener : ITextWatcher  If EditText can be multiline this listner will detect wheter the user presses \"Enter\" on their keyboard.    OnTouchListener : View.IOnTouchListener  ScrollListener : AbsListView.IOnScrollChangeListener",
            "title": "Android Listeners"
        }
    ]
}