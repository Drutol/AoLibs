{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AoLibs Set of various libraries that I happened to write during my Xamarin adventures. They are devised mainly for my own use but I took an effort to properly document them so that my co-workers or any other people I happen to develop with had easier time using them. Note I'm primarily developing on Android that's why Android side of things is better thought out and much richer than iOS counterpart. While all iOS things work they could certainly use an improvement. Feel free to use this code in whatever way you see fit. Features Library supports iOS and Android projects. It's divided into three parts: AoLibs.Navigation Provides cross platform navigation solution. AoLibs.Adapters Various adapters gathering features that require writing platform specific code. AoLibs.Utilities Completly random things that I tend to use in my projects. Samples You can find very simple samples in main repository: AoLibs.Sample.Android AoLibs.Sample.iOS You may also find some helpful code in test projects. Dependencies Info These libraries are built using MvvmLight libraries. Newtonsoft.Json is used for JSON serialization.","title":"Home"},{"location":"#aolibs","text":"Set of various libraries that I happened to write during my Xamarin adventures. They are devised mainly for my own use but I took an effort to properly document them so that my co-workers or any other people I happen to develop with had easier time using them. Note I'm primarily developing on Android that's why Android side of things is better thought out and much richer than iOS counterpart. While all iOS things work they could certainly use an improvement. Feel free to use this code in whatever way you see fit.","title":"AoLibs"},{"location":"#features","text":"Library supports iOS and Android projects. It's divided into three parts: AoLibs.Navigation Provides cross platform navigation solution. AoLibs.Adapters Various adapters gathering features that require writing platform specific code. AoLibs.Utilities Completly random things that I tend to use in my projects.","title":"Features"},{"location":"#samples","text":"You can find very simple samples in main repository: AoLibs.Sample.Android AoLibs.Sample.iOS You may also find some helpful code in test projects.","title":"Samples"},{"location":"#dependencies","text":"Info These libraries are built using MvvmLight libraries. Newtonsoft.Json is used for JSON serialization.","title":"Dependencies"},{"location":"about/","text":"About Welcome to About page! Nothing really important here... Info If you are curious about the origin of AoLibs... well that's because I really like this kanji which happen to read like \"Ao\" \u84bc It means \"blue\"... but can also mean \"green\"... strange right? Hence the theme of upper header bar. From blue to green ^^ Japanese is for sure strange language. Authors There's only 1 to be honest. Check out my GitHub account if you want to get in touch! Related projects To be announced, there are 2 currently in development.","title":"About"},{"location":"about/#about","text":"Welcome to About page! Nothing really important here... Info If you are curious about the origin of AoLibs... well that's because I really like this kanji which happen to read like \"Ao\" \u84bc It means \"blue\"... but can also mean \"green\"... strange right? Hence the theme of upper header bar. From blue to green ^^ Japanese is for sure strange language.","title":"About"},{"location":"about/#authors","text":"There's only 1 to be honest. Check out my GitHub account if you want to get in touch!","title":"Authors"},{"location":"about/#related-projects","text":"To be announced, there are 2 currently in development.","title":"Related projects"},{"location":"adapters-android/","text":"Android Adapters IContextProvider Some adapters require context to work, that's why they are accepting IContextProvider argument. You should provide your own implementation depending on your architecture. For example: private class ContextProvider : IContextProvider { public Activity CurrentContext => MainActivity.Instance; } IOnActivityEvent Is a mechanism that helps wrapping activity callbacks and delegating them in a more streamlined way. Let's consider: public class MainActivity : AppCompatActivity, IOnNewIntentProvider { ... protected override void OnNewIntent(Intent intent) { base.OnNewIntent(intent); _activityNewIntentEventHandler.Invoke(this, intent); } event EventHandler<Intent> IOnActivityEvent<Intent>.Received { add => _activityNewIntentEventHandler += value; remove => _activityNewIntentEventHandler -= value; } } Where IOnNewIntentProvider derives from IOnActivityEvent<T> . You are required to manually provide delegation of given event like above. Then you can register them like so for example: containerBuilder.Register(ctx => MainActivity.Instance) .As<IOnActivityResultProvider>() ... .As<IOnNewIntentProvider>(); AsyncWrapperExtension While the whole thing with IOnActivityEvent<T> may look cumbersome at first, it for sure saved me quite a bit of time later on. There's AndroidCallbacklAsyncWrapperExtension class which contains extension method: public static async Task<T> Await<T>( this IOnActivityEvent<T> activityEvent, CancellationToken cancellationToken = default) It lets you await callbacks without writing devious logic every time.","title":"Android Adapters"},{"location":"adapters-android/#android-adapters","text":"","title":"Android Adapters"},{"location":"adapters-android/#icontextprovider","text":"Some adapters require context to work, that's why they are accepting IContextProvider argument. You should provide your own implementation depending on your architecture. For example: private class ContextProvider : IContextProvider { public Activity CurrentContext => MainActivity.Instance; }","title":"IContextProvider"},{"location":"adapters-android/#ionactivityevent","text":"Is a mechanism that helps wrapping activity callbacks and delegating them in a more streamlined way. Let's consider: public class MainActivity : AppCompatActivity, IOnNewIntentProvider { ... protected override void OnNewIntent(Intent intent) { base.OnNewIntent(intent); _activityNewIntentEventHandler.Invoke(this, intent); } event EventHandler<Intent> IOnActivityEvent<Intent>.Received { add => _activityNewIntentEventHandler += value; remove => _activityNewIntentEventHandler -= value; } } Where IOnNewIntentProvider derives from IOnActivityEvent<T> . You are required to manually provide delegation of given event like above. Then you can register them like so for example: containerBuilder.Register(ctx => MainActivity.Instance) .As<IOnActivityResultProvider>() ... .As<IOnNewIntentProvider>();","title":"IOnActivityEvent"},{"location":"adapters-android/#asyncwrapperextension","text":"While the whole thing with IOnActivityEvent<T> may look cumbersome at first, it for sure saved me quite a bit of time later on. There's AndroidCallbacklAsyncWrapperExtension class which contains extension method: public static async Task<T> Await<T>( this IOnActivityEvent<T> activityEvent, CancellationToken cancellationToken = default) It lets you await callbacks without writing devious logic every time.","title":"AsyncWrapperExtension"},{"location":"adapters/","text":"Adapters The library comes packed with quite a few adapters that will help you avoid writing boilerplate code for platform dependent functionalities. Adapter is a class which provides same functionality that has to be implemented differently on different platforms. Provided adapters Main interfaces which can be used in shared codebase are found in AoLibs.Adapters.Core . IClipboardProvider IDataCache IDispatcherAdapter IFileStorageProvider ILifecycleInfoProvider IMessageBoxProvider IPhoneCallAdapter IPhotoPickerAdapter IPickerAdapter ISettingsProvider IUriLauncherAdapter IVersionProvider I'll provide more details on the ones that may be not obvious. DataCache It depends on IFileStorageProvider . Uses Json.NET to serialize given data and save it to file for storage. Object are wrapped in object with timestamp so it's possible to specify for how long this piece of data stays valid. DispatcherAdapter Runs action on UI thread... that's it. LifecycleInfoProvider Requires manual invocation of methods. SettingsProvider Provides set of methods allowing to storage data in application's settings construct.","title":"Adapters"},{"location":"adapters/#adapters","text":"The library comes packed with quite a few adapters that will help you avoid writing boilerplate code for platform dependent functionalities. Adapter is a class which provides same functionality that has to be implemented differently on different platforms.","title":"Adapters"},{"location":"adapters/#provided-adapters","text":"Main interfaces which can be used in shared codebase are found in AoLibs.Adapters.Core . IClipboardProvider IDataCache IDispatcherAdapter IFileStorageProvider ILifecycleInfoProvider IMessageBoxProvider IPhoneCallAdapter IPhotoPickerAdapter IPickerAdapter ISettingsProvider IUriLauncherAdapter IVersionProvider I'll provide more details on the ones that may be not obvious.","title":"Provided adapters"},{"location":"adapters/#datacache","text":"It depends on IFileStorageProvider . Uses Json.NET to serialize given data and save it to file for storage. Object are wrapped in object with timestamp so it's possible to specify for how long this piece of data stays valid.","title":"DataCache"},{"location":"adapters/#dispatcheradapter","text":"Runs action on UI thread... that's it.","title":"DispatcherAdapter"},{"location":"adapters/#lifecycleinfoprovider","text":"Requires manual invocation of methods.","title":"LifecycleInfoProvider"},{"location":"adapters/#settingsprovider","text":"Provides set of methods allowing to storage data in application's settings construct.","title":"SettingsProvider"},{"location":"android-layout-to-cs/","text":"Android Layout to CSharp I've built little application that is able to convert android layout defined in xml to C# code referencing controls with given ID. Info You can find repo here: https://github.com/Drutol/AndroidLayoutToCSharp Finally you receive code to copy&paste: #region Views private FrameLayout _rootView; public FrameLayout RootView => _rootView ?? (_rootView = FindViewById<FrameLayout>(Resource.Id.RootView)); #endregion It's built as an UWP app for Windows 10. Manual compilation and deployment required. Features It's capable of Generating general \"code-behind\" for all controls marked with android:id Recursively going through all files in specified folder in order to find controls added with <include> directive. Generating code for ViewHolders. Filtering IDs based on whether the ID starts with upper or lower character. Useful for IDs that are only used by layout in ConstraitLayout scenarios for example.","title":"Android Layout to C#"},{"location":"android-layout-to-cs/#android-layout-to-csharp","text":"I've built little application that is able to convert android layout defined in xml to C# code referencing controls with given ID. Info You can find repo here: https://github.com/Drutol/AndroidLayoutToCSharp Finally you receive code to copy&paste: #region Views private FrameLayout _rootView; public FrameLayout RootView => _rootView ?? (_rootView = FindViewById<FrameLayout>(Resource.Id.RootView)); #endregion It's built as an UWP app for Windows 10. Manual compilation and deployment required.","title":"Android Layout to CSharp"},{"location":"android-layout-to-cs/#features","text":"It's capable of Generating general \"code-behind\" for all controls marked with android:id Recursively going through all files in specified folder in order to find controls added with <include> directive. Generating code for ViewHolders. Filtering IDs based on whether the ID starts with upper or lower character. Useful for IDs that are only used by layout in ConstraitLayout scenarios for example.","title":"Features"},{"location":"android-listeners/","text":"Android Listeners Set of various listeners that are accepting delegates to native Android callback classes. DateSetListener : DatePickerDialog.IOnDateSetListener GenericMotionListener : View.IOnGenericMotionListener OnCheckedListener : RadioGroup.IOnCheckedChangeListener OnClickListener : View.IOnClickListener OnEditorActionListener : TextView.IOnEditorActionListener OnItemClickListener<T> : AdapterView.IOnItemClickListener Expects the item to be wrapped with JavaObjectWrapper<T> withing Tag property. OnLongClickListener : View.IOnLongClickListener OnScrollListener : AbsListView.IOnScrollListener OnTextEnterListener : ITextWatcher If EditText can be multiline this listener will detect whether the user presses \"Enter\" on their keyboard. OnTouchListener : View.IOnTouchListener ScrollListener : AbsListView.IOnScrollChangeListener","title":"Android Listeners"},{"location":"android-listeners/#android-listeners","text":"Set of various listeners that are accepting delegates to native Android callback classes. DateSetListener : DatePickerDialog.IOnDateSetListener GenericMotionListener : View.IOnGenericMotionListener OnCheckedListener : RadioGroup.IOnCheckedChangeListener OnClickListener : View.IOnClickListener OnEditorActionListener : TextView.IOnEditorActionListener OnItemClickListener<T> : AdapterView.IOnItemClickListener Expects the item to be wrapped with JavaObjectWrapper<T> withing Tag property. OnLongClickListener : View.IOnLongClickListener OnScrollListener : AbsListView.IOnScrollListener OnTextEnterListener : ITextWatcher If EditText can be multiline this listener will detect whether the user presses \"Enter\" on their keyboard. OnTouchListener : View.IOnTouchListener ScrollListener : AbsListView.IOnScrollChangeListener","title":"Android Listeners"},{"location":"android-recycler-adapters/","text":"Recycler View Adapters Adapters library contains set of adapters that eliminate need for creating custom adapter classes. Applicable types: Adapters: ObservableRecyclerAdapter<TItem, THolder> ObservableRecyclerAdapterWithFooter<TItem, THolder, TFooterHolder> ObservableRecyclerAdapterWithMultipleViewTypes<TItemBase, THolder> ObservableRecyclerAdapterWithMultipleViewTypesAndFooter<TItemBase, THolder, TFooterHolder> ViewHolder: BindingViewHolderBase<T> Utilities: ItemEntry SpecializedItemEntry<TSpecializedItem, TSpecializedHolder> These classes provide an easy way to quickly implement recycler views for various scenarios starting from simple list to elaborate lists with various ViewModel bound elements with different layouts. All of provided adapters are utilizing events of ObservableCollection<T> . The ObservableRecyclerAdapter<TItem, THolder> is base class for all other specialized adapters. Simple setup So let's say we want to set-up simple recycler view list. Let's assume we have layout already created with RecyclerView named RecyclerView RecyclerView.SetAdapter( adapter: new ObservableRecyclerAdapter<Item, ItemViewHolder>( items: ViewModel.Items, dataTemplate: DataTemplate, itemTemplate: ItemTemplate, holderFactory: HolderFactory)); private void DataTemplate(Item item, ItemViewHolder holder, int position) { holder.SomeTextView.Text = item.SomeTextValue; } private View ItemTemplate(int viewType) { return LayoutInflater.Inflate(Resource.Layout.some_item_layout, null); } private ItemViewHolder HolderFactory(ViewGroup parent, int viewType, View view) { return new ItemViewHolder(view); } We have 3 methods being passed to adapter's constructor: DataTemplate Here we are defining how to display given item in the list, you will receive current item and holder that will have to display it. ItemTemplate Here you should provide view that will be later bound to view holder. HolderFactory Here we are instantiating holder for our virtualized items. This parameter is optional if your holder has public parameterless constructor and you don't need custom instantiation. View Stretching Unless specified the views in RecyclerView won't stretch horizontally. I've provided simple utility that takes care of it. RecyclerView.SetAdapter( adapter: new ObservableRecyclerAdapter<Item, ItemViewHolder>( items: ViewModel.Items, dataTemplate: DataTemplate, itemTemplate: ItemTemplate, holderFactory: HolderFactory) {ApplyLayoutParams = true}); In order to use it you just have to set ApplyLayoutParams property to true . Item containers will be assigned with proper RecyclerView.LayoutParams after inflating. Footer Adapter with footer is very similar to standard adapter: RecyclerView.SetAdapter( new ObservableRecyclerAdapterWithFooter<Item, ItemViewHolder, FooterHolder>( items: ViewModel.Items, dataTemplate: DataTemplate, holderFactory: HolderFactory, itemTemplate: ItemTemplate, footerDataTemplate: FooterDataTemplate, footerFactory: FooterFactory, footerTemplate: FooterTemplate) {ApplyLayoutParams = true}); ... private View FooterTemplate(int viewType) { return LayoutInflater.Inflate(Resource.Layout.some_footer, null); } private FooterHolder FooterFactory(ViewGroup parent, int viewType, View view) { return new FooterHolder(view); } private void FooterDataTemplate(Item item, FooterHolder holder, int position) { holder.ViewModel = ViewModel; } All you have to do is to add 3 more delegates defining footer. Mind you that item argument in FooterDataTemplate is null as there's no item applicable for that position. Note: If your footer holder inherits from BindingViewHolderBase<TViewModel> the holder won't automatically update bindings, you have to assign your ViewModel manually to footer. Binding ViewHolders As I've previously mentioned it's possible to easily implement bindings for each list entry. All you have to do is to make your ViewHolder inherit from BindingViewHolderBase<TViewModel> . For example: private class SomeHolder : BindingViewHolderBase<SomeViewModel> { private readonly View _view; private TextView _totalPriceLabel; public FooterHolder(View view) : base(view) { _view = view; } public TextView TotalPriceLabel => _totalPriceLabel ?? (_totalPriceLabel = _view.FindViewById<TextView>(Resource.Id.TotalPriceLabel)); protected override void SetBindings() { Bindings.Add(this.SetBinding(() => ViewModel.TotalOrderPrice, () => TotalPriceLabel.Text) .ConvertSourceToTarget(arg => arg.ToString(\"C\"))); } } This view holder will make you implement SetBindings methods which works exactly the same as in Fragment's bindings. ViewModel swapping and bindings detaching will all be handled by the library. Adapters with multiple view types This is where the fun starts. We have this lovely class ObservableRecyclerAdapterWithMultipleViewTypes<TItemBase, THolder> which is inheriting from ObservableRecyclerAdapter<TItemBase,THolder> . Notice that there's no longer TItem but TItemBase that means we will provide list of various elements. You can go for object here but I encourage to make your models share same even empty interface for cleanliness sake. The constructor has changed too: ObservableRecyclerAdapterWithMultipleViewTypes(Dictionary<Type, IItemEntry> templates,IList<TItemBase> items) we will have to provide a definition of view per item. RecyclerView.SetAdapter( new ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem, RecyclerView.ViewHolder>( new Dictionary<Type, ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem, RecyclerView.ViewHolder>.IItemEntry> { { typeof(FriendListHeaderItem), new ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem, RecyclerView.ViewHolder>.SpecializedItemEntry<FriendListHeaderItem, SectionViewHolder> { SpecializedHolderFactory = HeaderHolderFactory, ItemTemplate = HeaderItemTemplate, SpecializedDataTemplate = HeaderDataTemplate } }, { typeof(InviteFriendItemViewModel), new ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem, RecyclerView.ViewHolder>.SpecializedItemEntry<InviteFriendItemViewModel, FriendViewHolder> { SpecializedHolderFactory = ItemHolderFactory, ItemTemplate = ItemTemplate, SpecializedDataTemplate = ItemDataTemplate } } }, ViewModel.Friends) {ApplyLayoutParams = true}); It may look intimidating at first but it's not that bad. Essentially we are providing pairs of Type and IItemEntry implementations that are found in the library. IFriendListItem is our TItemBase TViewHolder will usually be simple RecyclerView.ViewHolder Let's take a closer look on view-type definition. { typeof(InviteFriendItemViewModel), new ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem, RecyclerView.ViewHolder>.SpecializedItemEntry<InviteFriendItemViewModel, FriendViewHolder> { SpecializedHolderFactory = ItemHolderFactory, ItemTemplate = ItemTemplate, SpecializedDataTemplate = ItemDataTemplate } } First thing we provide is our concrete type that is contained within the items to display, easy enough. Now comes the second part, ObservableRecyclerAdapterWithMultipleViewTypes has inner classes: SpecializedItemEntry ItemEntry They are used to define the views. SpecializedItemEntry is an evolution of ItemEntry that handles type casting so we don't have to do it manually each time. public class SpecializedItemEntry<TSpecializedItem, TSpecializedHolder> : IItemEntry where TSpecializedItem : TItemBase where TSpecializedHolder : THolder Instead of getting TItemBase and THolder passed to our DataTemplate we will be getting solid instances of InviteFriendItemViewModel and FriendViewHolder . If you wish to do the casting manually you can use ItemEntry . Don't use HolderFactory and DataTemplate properties in SpecializedItemEntry and use SpecializedHolderFactory and SpecializedDataTemplate properties instead. Exception will be thrown otherwise. { typeof(RestaurantPageMenuItemViewModel), new ObservableRecyclerAdapterWithMultipleViewTypes< RestaurantPageViewModel.IRestaurantMenuItem, RecyclerView.ViewHolder>.ItemEntry { ItemTemplate = MenuItemTemplate, DataTemplate = MenuDataTemplate, HolderFactory = MenuHolderFactory } } Of course you can use your friend BindingViewHolderBase<TViewModel> to achieve bindings per list item too! Adapters with multiple view types and footer The ultimate form, handles just like ObservableRecyclerAdapterWithMultipleViewTypes with addition of 3 delegates like in ObservableRecyclerAdapterWithFooter . RecyclerView.SetAdapter( new ObservableRecyclerAdapterWithMultipleViewTypesAndFooter<ReceiptPresentPageViewModel.IReceiptItem , RecyclerView.ViewHolder, FooterViewHolder>( new Dictionary<Type, ObservableRecyclerAdapterWithMultipleViewTypes< ReceiptPresentPageViewModel.IReceiptItem, RecyclerView.ViewHolder>.IItemEntry> { { typeof(ReceiptHeaderItem), new ObservableRecyclerAdapterWithMultipleViewTypes< ReceiptPresentPageViewModel.IReceiptItem, RecyclerView.ViewHolder>. SpecializedItemEntry<ReceiptHeaderItem, HeaderViewHolder> { SpecializedHolderFactory = HeaderHolderFactory, ItemTemplate = HeaderItemTemplate, SpecializedDataTemplate = HeaderDataTemplate } }, { typeof(ReceiptOrderedDishItemViewModel), new ObservableRecyclerAdapterWithMultipleViewTypes< ReceiptPresentPageViewModel.IReceiptItem, RecyclerView.ViewHolder>. SpecializedItemEntry<ReceiptOrderedDishItemViewModel, OrderedDishViewHolder> { SpecializedHolderFactory = OrderedDishHolderFactory, ItemTemplate = OrderedDishItemTemplate, SpecializedDataTemplate = OrderedDishDataTemplate } }, { typeof(ReceiptOrderSectionFooterItem), new ObservableRecyclerAdapterWithMultipleViewTypes< ReceiptPresentPageViewModel.IReceiptItem, RecyclerView.ViewHolder>. SpecializedItemEntry<ReceiptOrderSectionFooterItem, SectionFooterViewHolder> { SpecializedHolderFactory = SectionFooterHolderFactory, ItemTemplate = SectionFooterItemTemplate, SpecializedDataTemplate = SectionFooterDataTemplate } } }, ViewModel.CurrentReceipt, FooterDataTemplate, FooterFactory, FooterTemplate) { ApplyLayoutParams = true });","title":"Android Recycler Adapters"},{"location":"android-recycler-adapters/#recycler-view-adapters","text":"Adapters library contains set of adapters that eliminate need for creating custom adapter classes. Applicable types: Adapters: ObservableRecyclerAdapter<TItem, THolder> ObservableRecyclerAdapterWithFooter<TItem, THolder, TFooterHolder> ObservableRecyclerAdapterWithMultipleViewTypes<TItemBase, THolder> ObservableRecyclerAdapterWithMultipleViewTypesAndFooter<TItemBase, THolder, TFooterHolder> ViewHolder: BindingViewHolderBase<T> Utilities: ItemEntry SpecializedItemEntry<TSpecializedItem, TSpecializedHolder> These classes provide an easy way to quickly implement recycler views for various scenarios starting from simple list to elaborate lists with various ViewModel bound elements with different layouts. All of provided adapters are utilizing events of ObservableCollection<T> . The ObservableRecyclerAdapter<TItem, THolder> is base class for all other specialized adapters.","title":"Recycler View Adapters"},{"location":"android-recycler-adapters/#simple-setup","text":"So let's say we want to set-up simple recycler view list. Let's assume we have layout already created with RecyclerView named RecyclerView RecyclerView.SetAdapter( adapter: new ObservableRecyclerAdapter<Item, ItemViewHolder>( items: ViewModel.Items, dataTemplate: DataTemplate, itemTemplate: ItemTemplate, holderFactory: HolderFactory)); private void DataTemplate(Item item, ItemViewHolder holder, int position) { holder.SomeTextView.Text = item.SomeTextValue; } private View ItemTemplate(int viewType) { return LayoutInflater.Inflate(Resource.Layout.some_item_layout, null); } private ItemViewHolder HolderFactory(ViewGroup parent, int viewType, View view) { return new ItemViewHolder(view); } We have 3 methods being passed to adapter's constructor: DataTemplate Here we are defining how to display given item in the list, you will receive current item and holder that will have to display it. ItemTemplate Here you should provide view that will be later bound to view holder. HolderFactory Here we are instantiating holder for our virtualized items. This parameter is optional if your holder has public parameterless constructor and you don't need custom instantiation.","title":"Simple setup"},{"location":"android-recycler-adapters/#view-stretching","text":"Unless specified the views in RecyclerView won't stretch horizontally. I've provided simple utility that takes care of it. RecyclerView.SetAdapter( adapter: new ObservableRecyclerAdapter<Item, ItemViewHolder>( items: ViewModel.Items, dataTemplate: DataTemplate, itemTemplate: ItemTemplate, holderFactory: HolderFactory) {ApplyLayoutParams = true}); In order to use it you just have to set ApplyLayoutParams property to true . Item containers will be assigned with proper RecyclerView.LayoutParams after inflating.","title":"View Stretching"},{"location":"android-recycler-adapters/#footer","text":"Adapter with footer is very similar to standard adapter: RecyclerView.SetAdapter( new ObservableRecyclerAdapterWithFooter<Item, ItemViewHolder, FooterHolder>( items: ViewModel.Items, dataTemplate: DataTemplate, holderFactory: HolderFactory, itemTemplate: ItemTemplate, footerDataTemplate: FooterDataTemplate, footerFactory: FooterFactory, footerTemplate: FooterTemplate) {ApplyLayoutParams = true}); ... private View FooterTemplate(int viewType) { return LayoutInflater.Inflate(Resource.Layout.some_footer, null); } private FooterHolder FooterFactory(ViewGroup parent, int viewType, View view) { return new FooterHolder(view); } private void FooterDataTemplate(Item item, FooterHolder holder, int position) { holder.ViewModel = ViewModel; } All you have to do is to add 3 more delegates defining footer. Mind you that item argument in FooterDataTemplate is null as there's no item applicable for that position. Note: If your footer holder inherits from BindingViewHolderBase<TViewModel> the holder won't automatically update bindings, you have to assign your ViewModel manually to footer.","title":"Footer"},{"location":"android-recycler-adapters/#binding-viewholders","text":"As I've previously mentioned it's possible to easily implement bindings for each list entry. All you have to do is to make your ViewHolder inherit from BindingViewHolderBase<TViewModel> . For example: private class SomeHolder : BindingViewHolderBase<SomeViewModel> { private readonly View _view; private TextView _totalPriceLabel; public FooterHolder(View view) : base(view) { _view = view; } public TextView TotalPriceLabel => _totalPriceLabel ?? (_totalPriceLabel = _view.FindViewById<TextView>(Resource.Id.TotalPriceLabel)); protected override void SetBindings() { Bindings.Add(this.SetBinding(() => ViewModel.TotalOrderPrice, () => TotalPriceLabel.Text) .ConvertSourceToTarget(arg => arg.ToString(\"C\"))); } } This view holder will make you implement SetBindings methods which works exactly the same as in Fragment's bindings. ViewModel swapping and bindings detaching will all be handled by the library.","title":"Binding ViewHolders"},{"location":"android-recycler-adapters/#adapters-with-multiple-view-types","text":"This is where the fun starts. We have this lovely class ObservableRecyclerAdapterWithMultipleViewTypes<TItemBase, THolder> which is inheriting from ObservableRecyclerAdapter<TItemBase,THolder> . Notice that there's no longer TItem but TItemBase that means we will provide list of various elements. You can go for object here but I encourage to make your models share same even empty interface for cleanliness sake. The constructor has changed too: ObservableRecyclerAdapterWithMultipleViewTypes(Dictionary<Type, IItemEntry> templates,IList<TItemBase> items) we will have to provide a definition of view per item. RecyclerView.SetAdapter( new ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem, RecyclerView.ViewHolder>( new Dictionary<Type, ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem, RecyclerView.ViewHolder>.IItemEntry> { { typeof(FriendListHeaderItem), new ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem, RecyclerView.ViewHolder>.SpecializedItemEntry<FriendListHeaderItem, SectionViewHolder> { SpecializedHolderFactory = HeaderHolderFactory, ItemTemplate = HeaderItemTemplate, SpecializedDataTemplate = HeaderDataTemplate } }, { typeof(InviteFriendItemViewModel), new ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem, RecyclerView.ViewHolder>.SpecializedItemEntry<InviteFriendItemViewModel, FriendViewHolder> { SpecializedHolderFactory = ItemHolderFactory, ItemTemplate = ItemTemplate, SpecializedDataTemplate = ItemDataTemplate } } }, ViewModel.Friends) {ApplyLayoutParams = true}); It may look intimidating at first but it's not that bad. Essentially we are providing pairs of Type and IItemEntry implementations that are found in the library. IFriendListItem is our TItemBase TViewHolder will usually be simple RecyclerView.ViewHolder Let's take a closer look on view-type definition. { typeof(InviteFriendItemViewModel), new ObservableRecyclerAdapterWithMultipleViewTypes<IFriendListItem, RecyclerView.ViewHolder>.SpecializedItemEntry<InviteFriendItemViewModel, FriendViewHolder> { SpecializedHolderFactory = ItemHolderFactory, ItemTemplate = ItemTemplate, SpecializedDataTemplate = ItemDataTemplate } } First thing we provide is our concrete type that is contained within the items to display, easy enough. Now comes the second part, ObservableRecyclerAdapterWithMultipleViewTypes has inner classes: SpecializedItemEntry ItemEntry They are used to define the views. SpecializedItemEntry is an evolution of ItemEntry that handles type casting so we don't have to do it manually each time. public class SpecializedItemEntry<TSpecializedItem, TSpecializedHolder> : IItemEntry where TSpecializedItem : TItemBase where TSpecializedHolder : THolder Instead of getting TItemBase and THolder passed to our DataTemplate we will be getting solid instances of InviteFriendItemViewModel and FriendViewHolder . If you wish to do the casting manually you can use ItemEntry . Don't use HolderFactory and DataTemplate properties in SpecializedItemEntry and use SpecializedHolderFactory and SpecializedDataTemplate properties instead. Exception will be thrown otherwise. { typeof(RestaurantPageMenuItemViewModel), new ObservableRecyclerAdapterWithMultipleViewTypes< RestaurantPageViewModel.IRestaurantMenuItem, RecyclerView.ViewHolder>.ItemEntry { ItemTemplate = MenuItemTemplate, DataTemplate = MenuDataTemplate, HolderFactory = MenuHolderFactory } } Of course you can use your friend BindingViewHolderBase<TViewModel> to achieve bindings per list item too!","title":"Adapters with multiple view types"},{"location":"android-recycler-adapters/#adapters-with-multiple-view-types-and-footer","text":"The ultimate form, handles just like ObservableRecyclerAdapterWithMultipleViewTypes with addition of 3 delegates like in ObservableRecyclerAdapterWithFooter . RecyclerView.SetAdapter( new ObservableRecyclerAdapterWithMultipleViewTypesAndFooter<ReceiptPresentPageViewModel.IReceiptItem , RecyclerView.ViewHolder, FooterViewHolder>( new Dictionary<Type, ObservableRecyclerAdapterWithMultipleViewTypes< ReceiptPresentPageViewModel.IReceiptItem, RecyclerView.ViewHolder>.IItemEntry> { { typeof(ReceiptHeaderItem), new ObservableRecyclerAdapterWithMultipleViewTypes< ReceiptPresentPageViewModel.IReceiptItem, RecyclerView.ViewHolder>. SpecializedItemEntry<ReceiptHeaderItem, HeaderViewHolder> { SpecializedHolderFactory = HeaderHolderFactory, ItemTemplate = HeaderItemTemplate, SpecializedDataTemplate = HeaderDataTemplate } }, { typeof(ReceiptOrderedDishItemViewModel), new ObservableRecyclerAdapterWithMultipleViewTypes< ReceiptPresentPageViewModel.IReceiptItem, RecyclerView.ViewHolder>. SpecializedItemEntry<ReceiptOrderedDishItemViewModel, OrderedDishViewHolder> { SpecializedHolderFactory = OrderedDishHolderFactory, ItemTemplate = OrderedDishItemTemplate, SpecializedDataTemplate = OrderedDishDataTemplate } }, { typeof(ReceiptOrderSectionFooterItem), new ObservableRecyclerAdapterWithMultipleViewTypes< ReceiptPresentPageViewModel.IReceiptItem, RecyclerView.ViewHolder>. SpecializedItemEntry<ReceiptOrderSectionFooterItem, SectionFooterViewHolder> { SpecializedHolderFactory = SectionFooterHolderFactory, ItemTemplate = SectionFooterItemTemplate, SpecializedDataTemplate = SectionFooterDataTemplate } } }, ViewModel.CurrentReceipt, FooterDataTemplate, FooterFactory, FooterTemplate) { ApplyLayoutParams = true });","title":"Adapters with multiple view types and footer"},{"location":"app-variables/","text":"AppVariables It's a higher level mechanism that uses ISettingsProvider and IFileStorageProvider to provide easy typed access to stored data. Note: It's only meant for reference types, don't use simple types. public class AppVariables : AppVariablesBase { public AppVariables(ISettingsProvider settingsProvider, IDataCache dataCache = null) : base(settingsProvider, dataCache) { } public AppVariables(ISyncStorage syncStorage, IAsyncStorage asyncStorage = null) : base(syncStorage, asyncStorage) { } [Variable] public Holder<TokenModel> TokenModel { get; set; } [Variable] public Holder<VideoLibrary> VideoLibrary { get; set; } } Single property of type Holder<T> marked with VariableAttribute takes care of most of your storage needs. Holder Wrapper that allows the library to interface with your data in \"managed\" way, it allows you to write the values to files or app settings via underlying implementations of ISyncStorage and IAsyncStorage . Out of the box it can handle ISettingsProvider as ISyncStorage and IDataCache as IAsyncStorage . Your data is cached in memory and not read every time you request it. VariableAttribute Allows to define additional behaviour for your data. MemoryOnly Stores the data only in memory always skipping both storage options. CustomKey By default property's name is used as key (file name or settings key), you can specify your own here. ExpirationTime Defines for how long the data is valid. By default only supported in IDataCache , you will have to implement own ISyncStorage in order to consume this setting there.","title":"AppVariables"},{"location":"app-variables/#appvariables","text":"It's a higher level mechanism that uses ISettingsProvider and IFileStorageProvider to provide easy typed access to stored data. Note: It's only meant for reference types, don't use simple types. public class AppVariables : AppVariablesBase { public AppVariables(ISettingsProvider settingsProvider, IDataCache dataCache = null) : base(settingsProvider, dataCache) { } public AppVariables(ISyncStorage syncStorage, IAsyncStorage asyncStorage = null) : base(syncStorage, asyncStorage) { } [Variable] public Holder<TokenModel> TokenModel { get; set; } [Variable] public Holder<VideoLibrary> VideoLibrary { get; set; } } Single property of type Holder<T> marked with VariableAttribute takes care of most of your storage needs.","title":"AppVariables"},{"location":"app-variables/#holder","text":"Wrapper that allows the library to interface with your data in \"managed\" way, it allows you to write the values to files or app settings via underlying implementations of ISyncStorage and IAsyncStorage . Out of the box it can handle ISettingsProvider as ISyncStorage and IDataCache as IAsyncStorage . Your data is cached in memory and not read every time you request it.","title":"Holder"},{"location":"app-variables/#variableattribute","text":"Allows to define additional behaviour for your data. MemoryOnly Stores the data only in memory always skipping both storage options. CustomKey By default property's name is used as key (file name or settings key), you can specify your own here. ExpirationTime Defines for how long the data is valid. By default only supported in IDataCache , you will have to implement own ISyncStorage in order to consume this setting there.","title":"VariableAttribute"},{"location":"installation/","text":"TODO","title":"Installation"},{"location":"installation/#todo","text":"","title":"TODO"},{"location":"navigation-android/","text":"Introduction The idea behind this navigation mechanism is similar to how WPF/UWP's <Frame> element works. Namely we are have one root page that hosts all other pages. These pages are managed by library within this frame. Setup All pages are hosted as Fragments , I'm assuming using single activity pattern. Given a single android activity with layout: <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"> <FrameLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/RootView\" /> </LinearLayout> Now we will want to initialize library from code. The RootView FrameLayout will be hosting all our pages within itself. protected override void OnCreate(Bundle savedInstanceState) { base.OnCreate(savedInstanceState); SetContentView(Resource.Layout.main); var pageDefinitions = new Dictionary<PageIndex, IPageProvider<NavigationFragmentBase>> { // cached {PageIndex.WelcomePage, new CachedPageProvider<WelcomePageFragment>()}, // oneshots {PageIndex.SignInPage, new OneshotPageProvider<SignInPageFragment>()}, }; var manager = new NavigationManager<PageIndex>( fragmentManager: SupportFragmentManager, rootFrame: RootView, pageDefinitions: pageDefinitions) } Now we can happily use our INavigationManager<TPageIdentifier> in our ViewModels! Additional configuration Adding new pages As we can see there are two pages defined WelcomePageFragment and SignInPageFragment . I'm providing base clases for fragments so it's very easy to add new content. Type hierarchy: INavigationPage NavigationFragmentBase FragmentBase<TViewModel> NavigationFragmentBase inherits from Android's Fragment class and wraps its functionality. Let's say we want to create new page SplashPage . 1. Create new class called for example SplashPageFragment 2. Make it inherit from FragmentBase<TViewModel> public class SplashPageFragment : FragmentBase<SplashViewModel> { public override int LayoutResourceId { get; } = Resource.Layout.splash_page; protected override void InitBindings() { } } There are 2 required elements: LayoutResourceId which indicates which layout the fragment is associated with. InitBinings method in which we will define our bindings to ViewModel. Add new entry in pageDefinitions Transition animations If you want to include transition animations when navigating you will want to use Action<FragmentTransaction> interceptTransaction parameter of NavigationManager 's constructor. It will expose FragmentTransaction so you change whatever you want before actually committing new page. For example: private void InterceptTransaction(FragmentTransaction fragmentTransaction) { fragmentTransaction.SetCustomAnimations( Resource.Animator.animation_slide_bottom, Resource.Animator.animation_fade_out); } ViewModel injection The generic parameter of FragmentBase<TViewModel> allows you to specify which ViewModel to pull for given fragment. ViewModel will be available in ViewModel property in your fragment. This requires providing implementation of IViewModelResolver interface which will pull appropriate ViewModels from your IoC for example. private class ViewModelResolver : IViewModelResolver { public TViewModel Resolve<TViewModel>() { using (var scope = ViewModelLocator.ObtainScope()) { return scope.Resolve<TViewModel>(); } } } This ViewModelResolver can be assigned to static property found on NavigationFragmentBase . NavigationFragmentBase.ViewModelResolver = new ViewModelResolver(); Bindings When we are talking navigation we are talking bindings lifecycle too. FragmentBase class handles them too. Since the library is based on MVVMLight library we are using its bindings. You will want to add all of them to Bindings which is of type List<Binding> , they will be properly attached and reattached when needed. You are supposed to add all your bindings in InitBindings method which is called once per fragment instance or when bindigs need to be recreated. If you don't have any bindings added to Bindings , yet you don't want the method to be fired again you can call this constructor: public NavigationFragmentBase(bool hasNonTrackableBindings = false); Example: protected override void InitBindings() { Bindings.Add(this.SetBinding(() => ViewModel.Toggle).WhenSourceChanges(() => { ToggleValue.Text = ViewModel.Toggle ? \"ON\" : \"OFF\"; })); Bindings.Add(this.SetBinding(() => ViewModel.Value, () => Value.Text)); } Disclaimer: Value and ToggleValue are TextViews . Notes The MainActivity will have to inherit AppCompatActivity .","title":"Android Navigation"},{"location":"navigation-android/#introduction","text":"The idea behind this navigation mechanism is similar to how WPF/UWP's <Frame> element works. Namely we are have one root page that hosts all other pages. These pages are managed by library within this frame.","title":"Introduction"},{"location":"navigation-android/#setup","text":"All pages are hosted as Fragments , I'm assuming using single activity pattern. Given a single android activity with layout: <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"> <FrameLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/RootView\" /> </LinearLayout> Now we will want to initialize library from code. The RootView FrameLayout will be hosting all our pages within itself. protected override void OnCreate(Bundle savedInstanceState) { base.OnCreate(savedInstanceState); SetContentView(Resource.Layout.main); var pageDefinitions = new Dictionary<PageIndex, IPageProvider<NavigationFragmentBase>> { // cached {PageIndex.WelcomePage, new CachedPageProvider<WelcomePageFragment>()}, // oneshots {PageIndex.SignInPage, new OneshotPageProvider<SignInPageFragment>()}, }; var manager = new NavigationManager<PageIndex>( fragmentManager: SupportFragmentManager, rootFrame: RootView, pageDefinitions: pageDefinitions) } Now we can happily use our INavigationManager<TPageIdentifier> in our ViewModels!","title":"Setup"},{"location":"navigation-android/#additional-configuration","text":"","title":"Additional configuration"},{"location":"navigation-android/#adding-new-pages","text":"As we can see there are two pages defined WelcomePageFragment and SignInPageFragment . I'm providing base clases for fragments so it's very easy to add new content. Type hierarchy: INavigationPage NavigationFragmentBase FragmentBase<TViewModel> NavigationFragmentBase inherits from Android's Fragment class and wraps its functionality. Let's say we want to create new page SplashPage . 1. Create new class called for example SplashPageFragment 2. Make it inherit from FragmentBase<TViewModel> public class SplashPageFragment : FragmentBase<SplashViewModel> { public override int LayoutResourceId { get; } = Resource.Layout.splash_page; protected override void InitBindings() { } } There are 2 required elements: LayoutResourceId which indicates which layout the fragment is associated with. InitBinings method in which we will define our bindings to ViewModel. Add new entry in pageDefinitions","title":"Adding new pages"},{"location":"navigation-android/#transition-animations","text":"If you want to include transition animations when navigating you will want to use Action<FragmentTransaction> interceptTransaction parameter of NavigationManager 's constructor. It will expose FragmentTransaction so you change whatever you want before actually committing new page. For example: private void InterceptTransaction(FragmentTransaction fragmentTransaction) { fragmentTransaction.SetCustomAnimations( Resource.Animator.animation_slide_bottom, Resource.Animator.animation_fade_out); }","title":"Transition animations"},{"location":"navigation-android/#viewmodel-injection","text":"The generic parameter of FragmentBase<TViewModel> allows you to specify which ViewModel to pull for given fragment. ViewModel will be available in ViewModel property in your fragment. This requires providing implementation of IViewModelResolver interface which will pull appropriate ViewModels from your IoC for example. private class ViewModelResolver : IViewModelResolver { public TViewModel Resolve<TViewModel>() { using (var scope = ViewModelLocator.ObtainScope()) { return scope.Resolve<TViewModel>(); } } } This ViewModelResolver can be assigned to static property found on NavigationFragmentBase . NavigationFragmentBase.ViewModelResolver = new ViewModelResolver();","title":"ViewModel injection"},{"location":"navigation-android/#bindings","text":"When we are talking navigation we are talking bindings lifecycle too. FragmentBase class handles them too. Since the library is based on MVVMLight library we are using its bindings. You will want to add all of them to Bindings which is of type List<Binding> , they will be properly attached and reattached when needed. You are supposed to add all your bindings in InitBindings method which is called once per fragment instance or when bindigs need to be recreated. If you don't have any bindings added to Bindings , yet you don't want the method to be fired again you can call this constructor: public NavigationFragmentBase(bool hasNonTrackableBindings = false); Example: protected override void InitBindings() { Bindings.Add(this.SetBinding(() => ViewModel.Toggle).WhenSourceChanges(() => { ToggleValue.Text = ViewModel.Toggle ? \"ON\" : \"OFF\"; })); Bindings.Add(this.SetBinding(() => ViewModel.Value, () => Value.Text)); } Disclaimer: Value and ToggleValue are TextViews .","title":"Bindings"},{"location":"navigation-android/#notes","text":"The MainActivity will have to inherit AppCompatActivity .","title":"Notes"},{"location":"navigation-ios/","text":"iOS Navigation Introduction It was certainly a challenge to bend native iOS navigation to match with overall concept and Android's capabilities. Finally I have achieved the freedom of managing the naviagrion stack however I see fit from shared code. Todo","title":"iOS Navigation"},{"location":"navigation-ios/#ios-navigation","text":"","title":"iOS Navigation"},{"location":"navigation-ios/#introduction","text":"It was certainly a challenge to bend native iOS navigation to match with overall concept and Android's capabilities. Finally I have achieved the freedom of managing the naviagrion stack however I see fit from shared code.","title":"Introduction"},{"location":"navigation-ios/#todo","text":"","title":"Todo"},{"location":"navigation/","text":"Navigation The goal is to provide lightweight solution for cross-platform navigation. The main interface you will be using in your shared codebase is INavigationManager<TPageIdentifier> where TPageIdentifier is usually a simple enum with all your pages. Example Below I'll describe shared concepts between Android and iOS. Setup and platform specific things are contained in separate pages. Page providers The page definitions dictionary takes in pair of TPageIdentifier which is simple enum in most cases and instance of class that implements IPageProvider<INavigationPage> . There are two implemented as of now: CachedPageProvider This provider preserves the state of its page so that when we navigate there it will look the same. OneshotPageProvider Here we are providing the page instance just once, each navigation will create new uninitialized page. The use-case of it is to avoid manually cleaning pages like RegisterPage . I suggest disabling cache in your IoC container for associated ViewModel. Navigation lifecycle events INavigationPage provides following events for you to override from platform specific class: public virtual void NavigatedTo(); public virtual void NavigatedBack(); public virtual void NavigatedFrom(); NavigatedTo Is called when we navigate forward to this fragment. eg. SignInPage -> DashboardPage DashboardPage invokes NavigatedTo NavigatedBack Called when we navigate backwards to the page we have already been on. eg. SignInPage <- DashboardPage SignInPage invokes NavigatedBack NavigatedFrom Is called whenever we leave the page. Navigation with arguments It's possible to invoke navigation with arguments. It allows us to separate ViewModels and avoid communication spaghetti code. INavigationManager<TPageIdentifier> allows to pass args parameter which is plain System.Object . These arguments will appear in NavigationArguments property within fragment class. Navigation backstack options There are defined following navigation options: public enum NavigationBackstackOption { AddToBackstack, SetAsRootPage, ClearBackstackToFirstOccurence, NoBackstack, ForceNewPageInstance } AddToBackstack Basic default option, current page will be added to backstack when navigating. SetAsRootPage Clears backstack and then navigates to given page essentially making it a root page. ClearBackstackToFirstOccurence Allows to \"jump\" to page that is already on backstack, let's say you have registration process consisting of multiple pages and once you are done you need to get back to \"Sign in\" page, with this option you can go back multiple pages. NoBackstack Current page won't be added to backstack on navigation. ForceNewPageInstance Requests IPageProvider to recreate page instance before navigating. Attribute based navigation When creating instance of INavigationManager there's a constructor overload that doesn't require you to pass dictionary mapping pages to providers. This constructor will search for all types from calling assembly via Assembly.GetCallingAssembly() and search for classes marked with NavigationPageAttribute . This attribute differs in Android vs iOS implementation but in its shared part it specifies: PageProviderType Specifies whether to use OneshotPageProvider or CachedPageProvider Page Specifies the integer value of an enum specified as PageIndex [NavigationPage((int) PageIndex.PageA, NavigationPageAttribute.PageProvider.Cached)] public class TestPageAFragment : FragmentBase<TestViewModelA>","title":"Navigation"},{"location":"navigation/#navigation","text":"The goal is to provide lightweight solution for cross-platform navigation. The main interface you will be using in your shared codebase is INavigationManager<TPageIdentifier> where TPageIdentifier is usually a simple enum with all your pages. Example Below I'll describe shared concepts between Android and iOS. Setup and platform specific things are contained in separate pages.","title":"Navigation"},{"location":"navigation/#page-providers","text":"The page definitions dictionary takes in pair of TPageIdentifier which is simple enum in most cases and instance of class that implements IPageProvider<INavigationPage> . There are two implemented as of now: CachedPageProvider This provider preserves the state of its page so that when we navigate there it will look the same. OneshotPageProvider Here we are providing the page instance just once, each navigation will create new uninitialized page. The use-case of it is to avoid manually cleaning pages like RegisterPage . I suggest disabling cache in your IoC container for associated ViewModel.","title":"Page providers"},{"location":"navigation/#navigation-lifecycle-events","text":"INavigationPage provides following events for you to override from platform specific class: public virtual void NavigatedTo(); public virtual void NavigatedBack(); public virtual void NavigatedFrom(); NavigatedTo Is called when we navigate forward to this fragment. eg. SignInPage -> DashboardPage DashboardPage invokes NavigatedTo NavigatedBack Called when we navigate backwards to the page we have already been on. eg. SignInPage <- DashboardPage SignInPage invokes NavigatedBack NavigatedFrom Is called whenever we leave the page.","title":"Navigation lifecycle events"},{"location":"navigation/#navigation-with-arguments","text":"It's possible to invoke navigation with arguments. It allows us to separate ViewModels and avoid communication spaghetti code. INavigationManager<TPageIdentifier> allows to pass args parameter which is plain System.Object . These arguments will appear in NavigationArguments property within fragment class.","title":"Navigation with arguments"},{"location":"navigation/#navigation-backstack-options","text":"There are defined following navigation options: public enum NavigationBackstackOption { AddToBackstack, SetAsRootPage, ClearBackstackToFirstOccurence, NoBackstack, ForceNewPageInstance } AddToBackstack Basic default option, current page will be added to backstack when navigating. SetAsRootPage Clears backstack and then navigates to given page essentially making it a root page. ClearBackstackToFirstOccurence Allows to \"jump\" to page that is already on backstack, let's say you have registration process consisting of multiple pages and once you are done you need to get back to \"Sign in\" page, with this option you can go back multiple pages. NoBackstack Current page won't be added to backstack on navigation. ForceNewPageInstance Requests IPageProvider to recreate page instance before navigating.","title":"Navigation backstack options"},{"location":"navigation/#attribute-based-navigation","text":"When creating instance of INavigationManager there's a constructor overload that doesn't require you to pass dictionary mapping pages to providers. This constructor will search for all types from calling assembly via Assembly.GetCallingAssembly() and search for classes marked with NavigationPageAttribute . This attribute differs in Android vs iOS implementation but in its shared part it specifies: PageProviderType Specifies whether to use OneshotPageProvider or CachedPageProvider Page Specifies the integer value of an enum specified as PageIndex [NavigationPage((int) PageIndex.PageA, NavigationPageAttribute.PageProvider.Cached)] public class TestPageAFragment : FragmentBase<TestViewModelA>","title":"Attribute based navigation"},{"location":"utilities-android/","text":"Android Utilities Views ScrollableSwipeToRefreshLayout Extension to SwipeRefreshLayout , allows to specify View the has scrolling capabilities in ScrollingView property. It will be later used to determine whether to or not allow refresh gesture. This gesture is only allowed while on the very top of the scrolling view. CanRefresh property will be used if SwipeRefreshLayout equals null Helpers JavaObjectWrapper<T> Simple wrapper so that we can easily place purely C# classes withing Tag property of View . Goes well with with provided extension methods: static T Unwrap<T>(this Java.Lang.Object obj) static JavaObjectWrapper<T> Wrap<T>(this T obj) DimensionsHelper Converts dp to px or px to dp Commands Set of 4 extension methods that help setting ICommand for View : void SetOnClickCommand(this View view, ICommand command) void SetOnClickCommand(this View view, ICommand command, Action<View,bool> onCanExecuteChanged) void SetOnClickCommand(this View view, ICommand command, object arg) void SetOnClickCommand(this View view, ICommand command, object arg, Action<View, bool> onCanExecuteChanged) These commands will subscribe to CanExecuteChanged event. By default Enabled property will be changed but you can also use overload with Action<View,bool> onCanExecuteChanged argument to customize behaviour. The other 2 variants allow passing object arg argument to ICommand 's Execute() method. Memory watcher Memory on android is precious. MemoryWatcher singleton allows to alert when the free memory drops below given percentage.","title":"Android Utilities"},{"location":"utilities-android/#android-utilities","text":"","title":"Android Utilities"},{"location":"utilities-android/#views","text":"ScrollableSwipeToRefreshLayout Extension to SwipeRefreshLayout , allows to specify View the has scrolling capabilities in ScrollingView property. It will be later used to determine whether to or not allow refresh gesture. This gesture is only allowed while on the very top of the scrolling view. CanRefresh property will be used if SwipeRefreshLayout equals null","title":"Views"},{"location":"utilities-android/#helpers","text":"JavaObjectWrapper<T> Simple wrapper so that we can easily place purely C# classes withing Tag property of View . Goes well with with provided extension methods: static T Unwrap<T>(this Java.Lang.Object obj) static JavaObjectWrapper<T> Wrap<T>(this T obj) DimensionsHelper Converts dp to px or px to dp","title":"Helpers"},{"location":"utilities-android/#commands","text":"Set of 4 extension methods that help setting ICommand for View : void SetOnClickCommand(this View view, ICommand command) void SetOnClickCommand(this View view, ICommand command, Action<View,bool> onCanExecuteChanged) void SetOnClickCommand(this View view, ICommand command, object arg) void SetOnClickCommand(this View view, ICommand command, object arg, Action<View, bool> onCanExecuteChanged) These commands will subscribe to CanExecuteChanged event. By default Enabled property will be changed but you can also use overload with Action<View,bool> onCanExecuteChanged argument to customize behaviour. The other 2 variants allow passing object arg argument to ICommand 's Execute() method.","title":"Commands"},{"location":"utilities-android/#memory-watcher","text":"Memory on android is precious. MemoryWatcher singleton allows to alert when the free memory drops below given percentage.","title":"Memory watcher"},{"location":"utilities/","text":"Utilities Set of various little helpers that I found useful. DateTimeExtensions DateTime DateTimeFromUnixTimestamp(this int timestamp) Takes epoch timestamp and converts it to DateTime object. int ToUnixTimestamp(this DateTime date) Converts DateTime to epoch integer. DiffUtility Helps diffing 2 collections. There are two extension methods for this utility: DiffResult<T> Diff<T>(this IEnumerable<T> first, IEnumerable<T> other, CompareDelegate<T> referenceComparer, IEqualityComparer<T> equalityComparer) You can provide IEqualityComparer<T> that will be used to compare the items. DiffResult<T> Diff<T>(this IEnumerable<T> first, IEnumerable<T> other, CompareDelegate<T> referenceComparer, CompareDelegate<T> equalityComparer = null) If you don't equalityComparer default .Equals() method will be utilised. Arguments: first Original collection other Altered collection referenceComparer Delegate that allows to differentiate same entities, you want to compare IDs here for example. equalityComparer Indicates whether the item differs in its contents from other. On output you will receive DiffResult<T> object: public class DiffResult<T> { public IEnumerable<T> Added { get; internal set; } public IEnumerable<T> Removed { get; internal set; } public IEnumerable<T> Unmodified { get; internal set; } public IEnumerable<T> Modified { get; internal set; } } All these operations defined in IEnumerable<T> are held back until they are enumerated. FileSizeUtility string GetHumanReadableBytesLength(long value) Takes byte count and outputs proper size string. Possible suffixes: SizeSuffixes = {\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"}; SmartObservableCollection Extension over ObservableCollection<T> . The smart part comes from addition of void AddRange(IEnumerable<T> range) method. Proper collection changed events will be issued for newly added items only in a batch. StringExtensions string FirstCharToUpper(this string input) string FirstCharToLower(this string input) string Wrap(this string s, string start, string end) string TrimWhitespaceInside(this string str, bool allWhitespce = true) Removes whitespace in the middle of the string, allWhitespace specifies if regex will be working with \\s or just \" \" . StringUtilities static int LevenshteinDistance(string s, string t) Calculates simple Levenshtein distance between given strings.","title":"Utilities"},{"location":"utilities/#utilities","text":"Set of various little helpers that I found useful.","title":"Utilities"},{"location":"utilities/#datetimeextensions","text":"DateTime DateTimeFromUnixTimestamp(this int timestamp) Takes epoch timestamp and converts it to DateTime object. int ToUnixTimestamp(this DateTime date) Converts DateTime to epoch integer.","title":"DateTimeExtensions"},{"location":"utilities/#diffutility","text":"Helps diffing 2 collections. There are two extension methods for this utility: DiffResult<T> Diff<T>(this IEnumerable<T> first, IEnumerable<T> other, CompareDelegate<T> referenceComparer, IEqualityComparer<T> equalityComparer) You can provide IEqualityComparer<T> that will be used to compare the items. DiffResult<T> Diff<T>(this IEnumerable<T> first, IEnumerable<T> other, CompareDelegate<T> referenceComparer, CompareDelegate<T> equalityComparer = null) If you don't equalityComparer default .Equals() method will be utilised. Arguments: first Original collection other Altered collection referenceComparer Delegate that allows to differentiate same entities, you want to compare IDs here for example. equalityComparer Indicates whether the item differs in its contents from other. On output you will receive DiffResult<T> object: public class DiffResult<T> { public IEnumerable<T> Added { get; internal set; } public IEnumerable<T> Removed { get; internal set; } public IEnumerable<T> Unmodified { get; internal set; } public IEnumerable<T> Modified { get; internal set; } } All these operations defined in IEnumerable<T> are held back until they are enumerated.","title":"DiffUtility"},{"location":"utilities/#filesizeutility","text":"string GetHumanReadableBytesLength(long value) Takes byte count and outputs proper size string. Possible suffixes: SizeSuffixes = {\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"};","title":"FileSizeUtility"},{"location":"utilities/#smartobservablecollection","text":"Extension over ObservableCollection<T> . The smart part comes from addition of void AddRange(IEnumerable<T> range) method. Proper collection changed events will be issued for newly added items only in a batch.","title":"SmartObservableCollection"},{"location":"utilities/#stringextensions","text":"string FirstCharToUpper(this string input) string FirstCharToLower(this string input) string Wrap(this string s, string start, string end) string TrimWhitespaceInside(this string str, bool allWhitespce = true) Removes whitespace in the middle of the string, allWhitespace specifies if regex will be working with \\s or just \" \" .","title":"StringExtensions"},{"location":"utilities/#stringutilities","text":"static int LevenshteinDistance(string s, string t) Calculates simple Levenshtein distance between given strings.","title":"StringUtilities"}]}